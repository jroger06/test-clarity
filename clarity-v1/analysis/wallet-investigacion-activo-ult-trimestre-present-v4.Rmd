---
title: "Wallet Investigacion <br/>"
output: html_document
---

```{r, echo = FALSE}
# This is the first mandatory section.

title     <- "Venta Digital: BBVA Wallet Bolsa Investigacion"

keywords  <- 'wallet, digital, online, bbva.es, transaccionalidad, navegacion, mailing'  
```

```{r, echo=FALSE}
# This is the second mandatory section.

suppressMessages(library(DBI))    # This avoids loading messages and warnings showing up
suppressMessages(library(rJava))
suppressMessages(library(ggplot2))
suppressMessages(library(grid))
suppressMessages(library(hexbin))
suppressMessages(library(lattice))
suppressMessages(library(reshape))
suppressMessages(library(plyr))
suppressMessages(library(stringr))
suppressMessages(library(digest))
suppressMessages(library(lattice))


options(warn=-1, scipen=3, width=150)
source('~/bda_clarity/tools/methods_connect.R') ;
source('~/bda_clarity/tools/warehouse_basics.R') ;
source('~/bda_clarity/tools/write.hive.R') ;
```

**Para el analisis se recoge información desde Noviembre 2013 hasta Marzo 2015. Para el análisis cuantitativo se excluirán empleados, clientes no particulares, menores de 18 años y mayores de 80 años. Además para las encuestas se excluirán clientes sin algún número de teléfono informado y clientes que no autorizan usar sus datos para campañas y no hayan firmado la LOPD. También deberían excluirse los que se oponenen a la nueva claúsula de la LOPD pero actualmente no se han podido identificar:**

<br/>

# A. Construcción colectivo y filtros

1. Se crea la tabla de clientes wallet apuntando como activos aquellos que se conectaron al menos una vez en el 1Q2015. Como inactivos cuentan los demás clientes que han descargado la app pero no se conectaron en el 1Q2015.

```{r TABLA_CLIENTES, eval=TRUE, echo=FALSE, cache=TRUE}
do.hive("create table IF NOT EXISTS da_mariadrav.wallet_clientes as
select actividad.cod_pers_trs,
partition_id_alta,
partition_id,
categoria_usuario
from da_martalamela.wallet_active_users_three_months actividad 
left join da_martalamela.wallet_user_partition_first_connection alta
  on cast(actividad.cod_pers_trs as int) = cast(alta.cod_pers_trs as int)
left join (select distinct cod_pers_trs, 
                  case when ind_conexion_wallet_ult_3m=1 then 'Wallet Activo' else 'Wallet Inactivo' end as categoria_usuario 
                  from da_martalamela.wallet_active_users_three_months 
                  where cast(partition_id as int)=20150331) actividad_3m
  on actividad.cod_pers_trs=actividad_3m.cod_pers_trs")
```

2. Se crea la tabla de clientes activos BBVANet: Clientes que accedieron a BBVANET al menos una vez en el 1Q2015. Se considera que un cliente accedió a BBVANET si en el mes pertenece en algúno de los segmentos comportamentales de 1 a 6:
<br/> *Segmentación comportamental:*
<br/> *1  Net contrata*
<br/> *2  Net opera elevado*
<br/> *3  Net opera básico*
<br/> *4  Net consulta ATM elevado*
<br/> *5  Net consulta ATM básico*
<br/> *6	Net consulta*
<br/> *7	ATM avanzado*
<br/> *8	ATM básico*
<br/> *9	Oficina ATM reducido*
<br/> *10	Oficina*
<br/> *11	Poco uso de canales*
<br/> *12	Sin uso*
<br/> Finalmente se extrae una muestra aleatoria de los clientes BBVANet de tamaño parecido que los wallet activos / inactivos y se junta con la tabla de clientes wallet unicos

```{r TABLA_BBVANET, eval=TRUE, echo=FALSE, cache=TRUE}
do.hive("create table IF NOT EXISTS da_mariadrav.wallet_bbvanet as
          select cod_pers_trs,
          rand() as random_number
          from
          (
            select distinct lpad(trim(cast(cod_cliente as string)), 9, '0') as cod_pers_trs
            from
            (
              select distinct cod_cliente, segmento_comportamental
              from da_segm_comport.segm_comport_perfil_digit_metricas_num_dias_20150331 
              union all 
              select distinct cod_cliente, segmento_comportamental
              from da_segm_comport.segm_comport_perfil_digit_metricas_num_dias_20150228 
              union all 
              select distinct cod_cliente, segmento_comportamental
              from da_segm_comport.segm_comport_perfil_digit_metricas_num_dias_20150131
            ) digi
           left join (select distinct cod_pers_trs, categoria_usuario
                       from da_mariadrav.wallet_clientes) uni
            on lpad(trim(cast(digi.cod_cliente as string)), 9, '0')=uni.cod_pers_trs
            where categoria_usuario is null and 
                  segmento_comportamental >= 1 and 
                  segmento_comportamental <= 6
          ) usuarionet
      ")

do.hive("create table IF NOT EXISTS da_mariadrav.wallet_bbvanet_sample as
        select b.cod_pers_trs, '' as partition_id_alta, a.partition_id, b.categoria_usuario
        from 
          (select distinct partition_id from da_mariadrav.wallet_clientes) a
          join 
          (select cod_pers_trs,
          'BBVANet' as categoria_usuario
          from da_mariadrav.wallet_bbvanet
          where random_number <= 134000/3502854
          ) b ")

do.hive("create table IF NOT EXISTS da_mariadrav.wallet_net_clientes as
        select *
        from  da_mariadrav.wallet_clientes
        union all
        select * from da_mariadrav.wallet_bbvanet_sample
        ")


```

3. Se pasa la tabla en SINFO para pegar información sociodemografica y de móvil informado. Finalmente se crea una tabla con clientes wallet activos, inactivos y BBVANet.

```{r VARIABLES_SINFO, eval=TRUE, echo=FALSE, cache=TRUE}
do.hive("create table IF NOT EXISTS da_mariadrav.wallet_net_clientes_uni as
        select distinct cod_pers_trs, partition_id_alta, categoria_usuario
        from da_mariadrav.wallet_net_clientes ")

# proc sql;
# create table wallet_sociodemo as 
# select 	DISTINCT
#  		a.da_mariadrav_wallet_net_clientes as cod_pers_trs,
#     a.var2 as partiton_id_alta,
#  	  a.var3 as categoria_usuario,
# 		b.tfno_gest, b.tfno_par, b.tfno_mov,
# 		b.cod_mailges, b.des_email,
# 		b.inf_telefono,
# 		b.inf_email,
# 		b.xsn_enviopub,
# 		b.xsn_enviotmk,
# 		b.xti_idefisco,
# 		b.xti_sexo,
# 		b.cod_edad,
# 		b.xsn_empleado,
# 		case when c.COD_MARCA in ('0229', '0305', '0310') then 1 else 0 end as filtro_lopd,
# 		d.DES_NOMCLIE,
# 		d.DES_NOMPILA ,
# 		d.DES_PRIAPELL ,
# 		d.DES_SEGAPELL ,
# 		min(d.FEC_ALBBVA , d.FEC_ALTA) as fec_alta format YYMMDD10.,
#   	intck('month', 
# 			  mdy(round((var2 - round(var2,10000))/100), var2-round(var2, 100), round(var2/10000)), 
# 			  mdy(03,31,2015)) as antiguedad_wallet_months,
# 		intck('month', calculated fec_alta, mdy(03,31,2015)) as antiguedad_months
# from wallet_clientes_uni_net a left join emailmovil_hoy b
# on a.da_mariadrav_wallet_net_clientes = b.cod_persona
# left join lopd.marcas_lopd c
# on a.da_mariadrav_wallet_net_clientes = input(trim(c.COD_PERSCTPN), 8.)
# left join sfmav.VSFMANFC d
# on a.da_mariadrav_wallet_net_clientes = d.cod_persona;
# quit;

```

<br/> **Esta es la distribución de los clientes según actividad Wallet:**
<br/> Wallet Activo:**`r qhive("select count(distinct cod_pers_trs) as dist_pers from da_mariadrav.wallet_sociodemo where categoria_usuario='Wallet Activo'")`**
<br/> Wallet Inactivo:**`r qhive("select count(distinct cod_pers_trs) as dist_pers from da_mariadrav.wallet_sociodemo where categoria_usuario='Wallet Inactivo'")`**
<br/> BBVANet:**`r qhive("select count(distinct cod_pers_trs) as dist_pers from da_mariadrav.wallet_sociodemo where categoria_usuario='BBVANet'")`**

```{r VARIABLES_TERRITORIAL_PLANUNO, eval=TRUE, echo=FALSE, cache=TRUE}
# **CRUCE: clarity_attributes.Big_Big_table: Ciudad, Segmento según Plan Uno.**
# Pegar campos de big_big_table
do.hive("create table IF NOT EXISTS da_mariadrav.wallet_sociodemo_ampl as 
        select a.*,
        b.cod_postal_ciudad_cod_postal as cod_postal, 
        b.cod_postal_ciudad_des_ciudadg as des_ciudadg,
        b.provincia,
        b.territorial,
        b.segmento_plan_uno_cod_segmento_plan_uno as segm_plan_uno
        from  
          da_mariadrav.wallet_sociodemo a 
        left join 
          (select distinct big.cod_persona, big.cod_postal_ciudad_cod_postal, 
           big.cod_postal_ciudad_des_ciudadg, big.segmento_plan_uno_cod_segmento_plan_uno,
           prov.provincia, prov.territorial       
           from clarity_attributes.big_big_table big left join da_mariadrav.provincias prov
           on substr(lpad(trim(cast(big.cod_postal_ciudad_cod_postal as string)), 5, '0'), 1, 2)=lpad(trim(cast(prov.cod_postal_prov as string)), 2, '0')
          ) b
        on cast(a.cod_pers_trs as int) = cast(b.cod_persona as int)")

```

<br/> 
**Se hace el análisis de los filtros a aplicar y el número de clientes afectados:**
<br/> Se excluyen: <br/>

* Filtro sd: Filtros sociodemográficos:
    + Empleados
    + Menores de edad y mayores de 80 años
    + Clientes no particulares <br/>

* Filtro tel:
    + Clientes sin ningún teléfono informado <br/>

* Filtro Robinson y TMK
    + Clientes que se han negado a ser contactados para ofertas comerciales o llamadas telefónicas<br/>

* Filtro LOPD
    + Clientes que no han firmado la cláusula de LOPD. PENDIENTE identificar los que se oponen a la nueva claúsula de LOPD

<br/> ***Escenario A: LOPD prevalece sobre Robinson***
<br/> 1. FILTRO sd+tel: Filtros imprescindibles (sociodemográficos): 
<br/> 2. FILTRO lopd: Filtro LOPD
<br/> 3. FILTRO rob: Filtro Robinson y TMK

```{r FILTROS_ESCENARIO_A, eval=TRUE, echo=FALSE, cache=TRUE}

qhive("select categoria_usuario, 
      count(*) as filtro_sd,
      sum(case when filtro_lopd = 1 then 1 else 0 end) as filtro_lopd,
      sum(case when filtro_lopd = 1 and xsn_enviopub != 'N' and xsn_enviotmk != 'N' then 1 else 0 end) as filtro_rob
      from da_mariadrav.wallet_sociodemo_ampl
      where xti_idefisco in ('1', '6', '7')
        and xti_sexo in ('M', 'V')
        and cod_edad>=18 and cod_edad<=80
        and xsn_empleado = ''
        and concat(tfno_gest,tfno_par,tfno_mov) != ''
      group by categoria_usuario
      ")
```

<br/> ***Escenario B: Robinson prevalece sobre LOPD***
<br/> 1. FILTRO sd+tel: Filtros imprescindibles (sociodemográficos): 
<br/> 2. FILTRO rob: Filtro Robinson y TMK
<br/> 3. FILTRO lopd: Filtro LOPD

```{r FILTROS_ESCENARIO_B, eval=TRUE, echo=FALSE, cache=TRUE}
qhive("select categoria_usuario, 
      count(*) as filtro_sd,
      sum(case when xsn_enviopub != 'N' and xsn_enviotmk != 'N' then 1 else 0 end) as filtro_rob,
      sum(case when xsn_enviopub != 'N' and xsn_enviotmk != 'N' and filtro_lopd = 1 then 1 else 0 end) as filtro_lopd
      from da_mariadrav.wallet_sociodemo_ampl
      where xti_idefisco in ('1', '6', '7')
        and xti_sexo in ('M', 'V')
        and cod_edad>=18 and cod_edad<=80
        and xsn_empleado = ''
        and concat(tfno_gest,tfno_par,tfno_mov) != ''
      group by categoria_usuario
      ")
```

<br/> Se comprueba que hay al menos 700 usuarios inactivos con antigüedad <= 6m para el estudio cuali. 
De hecho hay **`r qhive("select count(distinct cod_pers_trs) from da_mariadrav.wallet_sociodemo_ampl where antiguedad_wallet_months <= 6 and categoria_usuario ='Wallet Inactivo' and xti_idefisco in ('1', '6', '7')  and xti_sexo in ('M', 'V') and cod_edad>=18 and cod_edad<=80  and xsn_empleado = ''  and concat(tfno_gest,tfno_par,tfno_mov) != ''  and xsn_enviopub != 'N' and xsn_enviotmk != 'N'  and filtro_lopd = 1")`** clientes <br/> 

```{r FILTROS_ESCENARIOS_ANTIGUEDAD, eval=FALSE, echo=FALSE, cache=TRUE}
# Se hizo un estudio extra de la antigüedad en Wallet por categoría de filtro
# Añadir los filtros de antigüedad en Wallet. Se miran antigüedades de 6, 9, 12 meses. 

############################### Escenario A: LOPD prevalece de Robinson ##############################
qhive("select categoria_usuario, 
        sum(case when antiguedad_months <= 6 then 1 else 0 end) as sd_a_06,
        sum(case when antiguedad_months <= 9 then 1 else 0 end) as sd_a_09,
        sum(case when antiguedad_months <= 12 then 1 else 0 end) as sd_a_12,
        sum(case when filtro_lopd = 1 and antiguedad_months <= 6 then 1 else 0 end) as lopd_a_06,
        sum(case when filtro_lopd = 1 and antiguedad_months <= 9 then 1 else 0 end) as lopd_a_09,
        sum(case when filtro_lopd = 1 and antiguedad_months <= 12 then 1 else 0 end) as lopd_a_12,
        sum(case when filtro_lopd = 1 and xsn_enviopub != 'N' and xsn_enviotmk != 'N' and antiguedad_months <= 6 then 1 else 0 end) as rob_a_06,
        sum(case when filtro_lopd = 1 and xsn_enviopub != 'N' and xsn_enviotmk != 'N' and antiguedad_months <= 9 then 1 else 0 end) as rob_a_09,
        sum(case when filtro_lopd = 1 and xsn_enviopub != 'N' and xsn_enviotmk != 'N' and antiguedad_months <= 12 then 1 else 0 end) as rob_a_12
from da_mariadrav.wallet_sociodemo_ampl
where xti_idefisco in ('1', '6', '7')
  and xti_sexo in ('M', 'V')
  and cod_edad>=18 and cod_edad<=80
  and xsn_empleado = ''
  and concat(tfno_gest,tfno_par,tfno_mov) != ''
group by categoria_usuario")


############################### Escenario B: Robinson prevalece de LOPD ##############################
qhive("select categoria_usuario, 
        sum(case when antiguedad_months <= 6 then 1 else 0 end) as sd_a_06,
        sum(case when antiguedad_months <= 9 then 1 else 0 end) as sd_a_09,
        sum(case when antiguedad_months <= 12 then 1 else 0 end) as sd_a_12,
        sum(case when xsn_enviopub != 'N' and xsn_enviotmk != 'N' and antiguedad_months <= 6 then 1 else 0 end) as rob_a_06,
        sum(case when xsn_enviopub != 'N' and xsn_enviotmk != 'N' and antiguedad_months <= 9 then 1 else 0 end) as rob_a_09,
        sum(case when xsn_enviopub != 'N' and xsn_enviotmk != 'N' and antiguedad_months <= 12 then 1 else 0 end) as rob_a_12,
        sum(case when xsn_enviopub != 'N' and xsn_enviotmk != 'N' and filtro_lopd = 1 and antiguedad_months <= 6 then 1 else 0 end) as lopd_a_06,
        sum(case when xsn_enviopub != 'N' and xsn_enviotmk != 'N' and filtro_lopd = 1 and antiguedad_months <= 9 then 1 else 0 end) as lopd_a_09,
        sum(case when xsn_enviopub != 'N' and xsn_enviotmk != 'N' and filtro_lopd = 1 and antiguedad_months <= 12 then 1 else 0 end) as lopd_a_12
from da_mariadrav.wallet_sociodemo_ampl
where xti_idefisco in ('1', '6', '7')
  and xti_sexo in ('M', 'V')
  and cod_edad>=18 and cod_edad<=80
  and xsn_empleado = ''
  and concat(tfno_gest,tfno_par,tfno_mov) != ''
group by categoria_usuario")

```


<br/> **Finalmente se aplican los filtros sociodemográficos, obligatorios y así se crea el colectivo definitivo del análisis cuantitativo.**
```{r TABLA_BOLSA_CUANTI, eval=TRUE, echo=FALSE, cache=TRUE}
#Selección de muestra para el estudio cuanti
do.hive("create table IF NOT EXISTS da_mariadrav.wallet_clientes_bolsa_cuanti as 
        select  *
        from da_mariadrav.wallet_sociodemo_ampl
        where xti_idefisco in ('1', '6', '7')
          and xti_sexo in ('M', 'V')
          and cod_edad>=18 and cod_edad<=80
          and xsn_empleado = ''
        ")

```

La distribución de los clientes una vez aplicados los filtros sociodemográficos es la siguiente:
<br/> Wallet Activo:**`r qhive("select count(distinct cod_pers_trs) as dist_pers from da_mariadrav.wallet_clientes_bolsa_cuanti where categoria_usuario='Wallet Activo'")`**
<br/> Wallet Inactivo:**`r qhive("select count(distinct cod_pers_trs) as dist_pers from da_mariadrav.wallet_clientes_bolsa_cuanti where categoria_usuario='Wallet Inactivo'")`**
<br/> BBVANet:**`r qhive("select count(distinct cod_pers_trs) as dist_pers from da_mariadrav.wallet_clientes_bolsa_cuanti where categoria_usuario='BBVANet'")`**

```{r VARIABLES_COMPORTAMENTAL, eval=TRUE, echo=FALSE, cache=TRUE}
#**Añadir información del segmento comportamental.**
do.hive("create table IF NOT EXISTS da_mariadrav.wallet_bolsa_segmcomp as 
        select a.cod_pers_trs, 
        b.segmento_comportamental,
        b.mix_actividad,
        b.frecuencia
        from da_mariadrav.wallet_clientes_bolsa_cuanti a left join clarity_elements.metricas_segm_comport b
        on cast(trim(a.cod_pers_trs) as int) = b.cod_persona")
```

```{r TABLA_BOLSA_CUANTI_PARTITION, eval=TRUE, echo=FALSE, cache=TRUE}
# crear la tabla bolsa_cuanti con partition_id
do.hive("create table IF NOT EXISTS da_mariadrav.wallet_clientes_bolsa_cuanti_partition as
        select a.*, b.partition_id
        from da_mariadrav.wallet_clientes_bolsa_cuanti a left join da_mariadrav.wallet_net_clientes b
        on cast(trim(a.cod_pers_trs)as int)=cast(trim(b.cod_pers_trs)as int)")
```

```{r VARIABLES_TENENCIA_TARJETAS, eval=TRUE, echo=FALSE, cache=TRUE}
#**Añadir información de tenencia de la tarjeta Wallet o Sticker**
do.hive("create table IF NOT EXISTS da_mariadrav.wallet_bolsa_tar_stick_num as   
  select bolsa.cod_pers_trs, bolsa.partition_id,
  num_tar_wallet, num_sticker, num_habitual, debito_credito
  from wallet_clientes_bolsa_cuanti_partition bolsa
  left join 
  (
    select cod_persctpn, partition_id, 
    count(distinct prod.cod_idcontra) as num_tar_wallet
    from da_pro.intervinientes_corp inter, da_pro.productos_contratados prod
    where inter.cod_idcontra=prod.cod_idcontra  
            and inter.partition_id=prod.partition_id  
            and inter.partition_id >= '20131130' and inter.partition_id <= '20150331'
            and cast(trim(prod.cod_comprod) as int) = 8425
            group by cod_persctpn, inter.partition_id
    ) inter1
    on cast(trim(bolsa.cod_pers_trs) as int) = cast(trim(inter1.cod_persctpn) as int)
       and bolsa.partition_id=inter1.partition_id
    left join 
    (
    select cod_persctpn, partition_id, 
    count(distinct prod.cod_idcontra) as num_sticker
    from da_pro.intervinientes_corp inter, da_pro.productos_contratados prod
    where inter.cod_idcontra=prod.cod_idcontra  
            and inter.partition_id=prod.partition_id  
            and inter.partition_id >= '20131130' and inter.partition_id <= '20150331'
            and cast(trim(prod.cod_comprod) as int) = 3199
            group by cod_persctpn, inter.partition_id
    ) inter2
    on cast(trim(bolsa.cod_pers_trs) as int) = cast(trim(inter2.cod_persctpn) as int)
       and bolsa.partition_id=inter2.partition_id
    left join 
    (
    select cod_persctpn, partition_id, 
      case when cast(prod.cod_pgccontr as int)=615 then 'Credito'
        when cast(prod.cod_pgccontr as int)=616 then 'Debito'
        end as debito_credito,
    count(distinct prod.cod_idcontra) as num_habitual
    from da_pro.intervinientes_corp inter, da_pro.productos_contratados prod
    where inter.cod_idcontra=prod.cod_idcontra  
            and inter.partition_id=prod.partition_id  
            and inter.partition_id >= '20131130' and inter.partition_id <= '20150331'
            and cast(trim(prod.cod_comprod) as int) in (369,2265,6709,2366,
                                           3037,9994,2497,2154,2306,7938,
                                           9482,2494,2496,4169,561,9841,
                                           5990,6048,2511,5989)
            group by cod_persctpn, inter.partition_id, prod.cod_pgccontr
    ) inter3
    on cast(trim(bolsa.cod_pers_trs) as int) = cast(trim(inter3.cod_persctpn) as int)
       and bolsa.partition_id=inter3.partition_id")


```

```{r VARIABLES_FUNCIONALIDADES, eval=FALSE, echo=FALSE, cache=TRUE}
#**Añadir información de funcionalidades**
# 1. activación de tarjetas - cod_trnfims 1231
# 2. bloqueo de tarjetas - cod_trnfims 0498 o TCTFT931
# 4. consulta de movimientos - cod_trnfims 0190 o TCTFT976 o 0559 (prepago)
# 5. aplazamiento de pagos - cod_trnfims 1620 o TCTFTL66
# 6. recepción de notificaciones - cod_trnfims 1681 (baja) o 1680 (alta)
# 7. acción comercial Wallet

do.hive("create table IF NOT EXISTS da_mariadrav.wallet_funcionalidades as
        select bolsa.*, 
        case when cod_persona != '' then 1 else 0 end as accion_comercial
        from (
                select bolsa.cod_pers_trs,  bolsa.partition_id,
                max(case when trim(trans.cod_trnfims) = '00001231' then 1 else 0 end) as activacion_tarjetas,
                max(case when trim(trans.cod_trnfims) in ('00000498', 'TCTFT931') then 1 else 0 end) as bloqueo_tarjetas,
                max(case when trim(trans.cod_trnfims) in ('00000190', 'TCTFT976', '00000559') then 1 else 0 end) as consulta_movim,
                max(case when trim(trans.cod_trnfims) in ('00001620', 'TCTFTL66') then 1 else 0 end) as aplazamiento_pagos,
                sum(case when trim(trans.cod_trnfims) = '00001620' then imp_trans else 0 end) as imp_aplazamiento_pagos,
                sum(case when trim(trans.cod_trnfims) = '00001620' then 1 else 0 end) as num_aplazamiento_pagos,
                max(case when trim(trans.cod_trnfims) = '00001681' then 1 else 0 end) as notificaciones_baja,
                max(case when trim(trans.cod_trnfims) = '00001680' then 1 else 0 end) as notificaciones_alta,
                trans.hour_soli_trn
                from (
                      select distinct cod_pers_trs, partition_id 
                      from da_mariadrav.wallet_clientes_bolsa_cuanti_partition
                     ) bolsa
                left join 
                    ( select distinct cod_pers_trs, cod_trnfims, partition_id, 
                      hour(hms_soli_trn) as hour_soli_trn, imp_trans
                      from da_pro.transacciones_por_canal 
                      where cast(cod_serv_dv as int) in (101, 102)
                        and partition_id >= '20131130' and partition_id <= '20150331'
                        and (cast(cod_trnfims as int) in (1231, 498, 190, 559, 1620, 1681, 1680) 
                              or trim(cod_trnfims) in ('TCTFT931', 'TCTFT976', 'TCTFTL66'))
                      ) trans 
                on cast(trim(bolsa.cod_pers_trs) as int) = cast(trim(trans.cod_pers_trs) as int)
                and bolsa.partition_id=trans.partition_id
                group by bolsa.cod_pers_trs, bolsa.partition_id, trans.hour_soli_trn
            ) as bolsa
        left join
          (
          select distinct cod_persona, fap_acom
          from da_mariadrav.wallet_accop_comercial
          where cod_canal='0101'
          )  as opcom
        on cast(trim(cod_pers_trs) as int) = cast(trim(cod_persona) as int)
        and concat(substr(partition_id,1,4), substr(partition_id,5,2)) =concat(substr(fap_acom, 1, 4), substr(fap_acom, 6, 2)) ")

# 3. pago móvil, diferenciando si ha sido con o sin sticker

do.hive("create table IF NOT EXISTS da_mariadrav.wallet_intervinientes_corp as
        select distinct tablon.cod_pers_trs,
        tablon.categoria_usuario,
        tablon.partition_id,
        contratos.cod_idcontra
        from da_mariadrav.wallet_clientes_bolsa_cuanti_partition tablon
        left join
        (
          select distinct cod_persctpn,
          cod_idcontra,
          partition_id
          from da_pro.intervinientes_corp
          where partition_id>='20131130' and partition_id<='20150331'
        ) contratos
        on cast(trim(tablon.cod_pers_trs) as int)=cast(trim(contratos.cod_persctpn) as int)
        order by cod_pers_trs,partition_id,cod_idcontra")

do.hive("        
create table IF NOT EXISTS da_mariadrav.wallet_tarjetas_cod_comprod as
        select dtdc.cod_idcontra,
        interv.cod_pers_trs,
        dtdc.cod_comprod,
        dtdc.cod_pgccontr,
        interv.partition_id,
        case when cast(dtdc.cod_comprod as int)=3199 then 'Sticker'
        when cast(cod_comprod as int)=8425 then 'Tarjeta Wallet'
        else 'Habitual' end as tipo_tarjeta,
        case when cast(dtdc.cod_pgccontr as int)=615 then 'Credito'
        when cast(dtdc.cod_pgccontr as int)=616 then 'Debito'
        end as debito_credito
        from 
        (
          select distinct cod_idcontra, cod_comprod, cod_pgccontr, partition_id
          from da_pro.datos_tarjetas_detalle_corp 
          where cod_paisoalf like 'ES'
            and cod_entalfa like '0182'
            and cast(cod_comprod as int) in (3199,8425,2369,2265,6709,2366,
                                           3037,9994,2497,2154,2306,7938,
                                           9482,2494,2496,4169,561,9841,
                                           5990,6048,2511,5989)
            and partition_id>='20131130' and partition_id<='20150331'
         ) dtdc
        left join
        (
         select distinct cod_idcontra,
         cod_pers_trs,
           partition_id
         from da_mariadrav.wallet_intervinientes_corp
        ) interv
        on cast(trim(dtdc.cod_idcontra) as int)=cast(trim(interv.cod_idcontra) as int) and 
        dtdc.partition_id=interv.partition_id
        where interv.cod_idcontra is not null
        order by cod_idcontra, partition_id   ")

do.hive("create table IF NOT EXISTS da_mariadrav.wallet_tarjetas_cod_comprod_resumen as
        select
        tablon.cod_pers_trs,
        tablon.categoria_usuario,
        tablon.partition_id,
        tarjetas.tipo_tarjeta,
        tarjetas.debito_credito,
        tarjetas.num_tarjetas
        from da_mariadrav.wallet_clientes_bolsa_cuanti_partition tablon
        left join
        (
          select cod_pers_trs,
          partition_id,
          tipo_tarjeta,
          debito_credito,
          count(distinct cod_idcontra) as num_tarjetas
          from da_mariadrav.wallet_tarjetas_cod_comprod
          group by cod_pers_trs, partition_id, tipo_tarjeta, debito_credito
        ) tarjetas
        on cast(trim(tablon.cod_pers_trs) as int)=cast(trim(tarjetas.cod_pers_trs) as int) 
        and tablon.partition_id=tarjetas.partition_id
        order by cod_pers_trs, categoria_usuario, partition_id, tipo_tarjeta")

do.hive("create table IF NOT EXISTS da_mariadrav.wallet_mtdc_cod_comprod as
        select tarjetas.partition_id,
        tarjetas.cod_comprod,
        tarjetas.cod_pgccontr,
        tarjetas.tipo_tarjeta,
        tarjetas.debito_credito,
        tarjetas.cod_pers_trs,
        sum(movim.num_movimientos) as num_movimientos, 
        sum(movim.imp_movimientos) as imp_movimientos
        from
        (
        select distinct partition_id, cod_idcontra, cod_comprod, cod_pgccontr, tipo_tarjeta, debito_credito, cod_pers_trs
        from da_mariadrav.wallet_tarjetas_cod_comprod
        ) tarjetas
        join 
        (select cod_idcontra, partition_id,
         count(*) as num_movimientos,
         sum(imp_mvimient) as imp_movimientos
          from da_pro.movimientos_tarjetas_detalle_corp 
         where cod_tip_regi like '%D%'
          and cod_tip_movi like '%0005%'
          and partition_id>='20131130' and partition_id<='20150331'
          group by cod_idcontra, partition_id
         ) movim
                on cast(trim(movim.cod_idcontra) as int) = cast(trim(tarjetas.cod_idcontra) as int)
                and movim.partition_id=tarjetas.partition_id
        where cod_comprod is not null
        group by tarjetas.cod_pers_trs, tarjetas.partition_id, tarjetas.cod_comprod, tarjetas.cod_pgccontr, 
        tarjetas.tipo_tarjeta, tarjetas.debito_credito ")

do.hive("create table IF NOT EXISTS da_mariadrav.wallet_pago_tarjetas as
        select
        tablon.*,
        movimientos.num_movimientos,
        movimientos.imp_movimientos
        from da_mariadrav.wallet_tarjetas_cod_comprod_resumen tablon
        left join
        (
          select cod_pers_trs,
          partition_id,
          tipo_tarjeta,
          debito_credito,
          sum(num_movimientos) as num_movimientos,
          sum(imp_movimientos) as imp_movimientos
          from da_mariadrav.wallet_mtdc_cod_comprod
          group by cod_pers_trs, partition_id, tipo_tarjeta, debito_credito
        ) movimientos
        on cast(trim(tablon.cod_pers_trs) as int)=cast(trim(movimientos.cod_pers_trs) as int)
        and tablon.partition_id= movimientos.partition_id
        and tablon.tipo_tarjeta= movimientos.tipo_tarjeta
        and tablon.debito_credito=movimientos.debito_credito
        order by cod_pers_trs, categoria_usuario, partition_id, tipo_tarjeta")

# do.hive("drop table da_mariadrav.wallet_intervinientes_corp")
# do.hive("drop table da_mariadrav.wallet_tarjetas_cod_comprod")
# do.hive("drop table wallet_tarjetas_cod_comprod_resumen")
# do.hive("drop table wallet_mtdc_cod_comprod")


```   

```{r VARIABLES_OTROS_PRODUCTOS, eval=TRUE, echo=FALSE, cache=TRUE}
#**Añadir información de tenencia otros productos financieros en BBVA**
do.hive("create table IF NOT EXISTS da_mariadrav.relacion_cliente_prod_tiempo as
    select * from
    (
      SELECT 
  cod_persctpn as cod_persona, 
  cod_pgccontr, 
	max(trim( if( productos_contratados.cod_comprod is null , productos_contratados_detalle.cod_comprod, productos_contratados.cod_comprod))) cod_comprod,
	max(trim( if( productos_contratados.cod_pro_plat is null , productos_contratados_detalle.cod_pro_plat, productos_contratados.cod_pro_plat))) cod_pro_plat,
    cod_idcontra,
     partition_id
	FROM da_pro.intervinientes_corp inter
	LEFT OUTER JOIN 
    (
       SELECT 
       cod_idcontra, 
       max(cod_comprod) cod_comprod, 
       max(cod_pro_plat) cod_pro_plat
       FROM da_pro.productos_contratados
       where partition_id>='20131130' and partition_id<='20150331'
       GROUP BY cod_idcontra, partition_id
     ) productos_contratados
	ON (trim(inter.cod_idcontra) = trim(productos_contratados.cod_idcontra ))
  	LEFT OUTER JOIN 
	( 
      SELECT 
      cod_idcontra, 
      max(cod_comprod) cod_comprod, 
      max(cod_pro_plat) cod_pro_plat
      FROM da_pro.productos_contratados_detalle
      where partition_id>='20131130' and partition_id<='20150331'
      GROUP BY cod_idcontra, partition_id
     ) productos_contratados_detalle
	ON (trim(inter.cod_idcontra) = trim(productos_contratados_detalle.cod_idcontra ))
      WHERE inter.cod_idcontra is not null and inter.cod_persctpn is not null
      and partition_id>='20131130' and partition_id<='20150331'
      and CAST(cod_entalfa AS INT) = 182 
  	AND trim(cod_ctippe) = 'TIT' 
    AND cast(cod_ordentit as int) = 1
  	AND cod_paisoalf LIKE 'ES' 
  	AND inter.cod_idcontra is not null
	GROUP BY inter.cod_idcontra, cod_pgccontr, cod_persctpn, partition_id
      ) inter
	LEFT OUTER JOIN
   	(
	  SELECT 
	  cod_ccontr, 
	  max(des_ctgcom) as des_ctgcom 
	  FROM catalogos_estaticos.jerarquia_abp_productos
	  GROUP BY cod_ccontr 
	) jerarquia_ABP_1
	ON ( CAST(inter.cod_pgccontr as INT) = CAST(jerarquia_ABP_1.cod_ccontr AS INT) )
	LEFT OUTER JOIN 
    ( 
	  SELECT 
      cod_cclaco, 
	  max(des_agrcom) as des_agrcom 
	  FROM catalogos_estaticos.jerarquia_abp_productos
      where trim(cod_cclaco)!=''
	  GROUP BY cod_cclaco
	) jerarquia_ABP_2
	ON ( CAST(inter.cod_comprod as INT) = CAST(jerarquia_ABP_2.cod_cclaco AS INT) AND 
         CAST(inter.cod_pgccontr as INT) = CAST(jerarquia_ABP_1.cod_ccontr AS INT) )

        ")

do.hive("create table IF NOT EXISTS da_mariadrav.wallet_bolsa_prod as
        select distinct bolsa.cod_pers_trs, bolsa.partition_id, 
          clipro.cod_comprod,
          clipro.des_ctgcom
        from da_mariadrav.wallet_clientes_bolsa_cuanti_partition as bolsa 
        left join 
        (select distinct partition_id, cod_comprod, des_ctgcom, cod_persona
        from da_mariadrav.relacion_cliente_prod_tiempo) clipro
        on cast(trim(bolsa.cod_pers_trs) as int) = cast(clipro.cod_persona as int) ")


#Añadir información de contrapartida. 
do.hive("create table IF NOT EXISTS da_mariadrav.productos as 
        select distinct cod_pers_trs, 
        contratos.partition_id, 
        productos.contrapartida, 
        productos.cod_comprod
        from (
              select distinct tablon.cod_pers_trs,
              tablon.partition_id,
              contratos.cod_idcontra
              from da_mariadrav.wallet_clientes_bolsa_cuanti_partition tablon
              left join
              (
                select distinct cod_persctpn,
                cod_idcontra,
                partition_id
                from da_pro.intervinientes_corp
                where partition_id>='20131130' and partition_id<='20150331'
              ) contratos
              on cast(trim(tablon.cod_pers_trs) as int)=cast(trim(contratos.cod_persctpn) as int)
              and tablon.partition_id=contratos.partition_id
            ) contratos
        left join 
        (
        select distinct partition_id, 
        substr(cod_masccntr, 9, 4) as contrapartida, 
        cod_comprod, 
        cod_idcontra
        from da_pro.saldos_cuenta_persona_fisica
        where partition_id>='20131130' and partition_id='20150331'
          and cast(trim(cod_entalfa) as int) = 182
          and trim(cod_situdw) = 'A'
          and cast(substr(cod_masccntr, 9, 4) as int) is not NULL
        ) productos
        on contratos.cod_idcontra=productos.cod_idcontra
        and contratos.partition_id=productos.partition_id")

# Combinación de las dos fuentes
do.hive("create table IF NOT EXISTS da_mariadrav.productos_comb as
        select distinct b.cod_pers_trs, 
        case  when upper(trim(a.des_contrapartida)) like '%BITO/CR%' then 'TARJETAS DEBITO/CREDITO'
              when upper(trim(a.des_contrapartida)) like '%FONDOS DE INVERSI%' then 'FONDOS DE INVERSION' 
              when upper(trim(a.des_contrapartida)) like '%O DE REMESAS%' then 'ENVIO DE REMESAS'
              when upper(trim(a.des_contrapartida)) like '%GARANT%' then 'GARANTIAS'
        else a.des_contrapartida end as des_contrapartida, 
        b.categoria_usuario
        from (
              select distinct a.cod_pers_trs, b.des_contrapartida 
              from (select distinct a.cod_pers_trs,  a.des_ctgcom
                    from da_mariadrav.wallet_bolsa_prod a join da_mariadrav.productos b
                    on a.cod_pers_trs=b.cod_pers_trs and a.cod_comprod = b.cod_comprod
                    where a.des_ctgcom is not NULL) a
              left join da_mariadrav.relacion_cgtcom_contrapartida b
              on upper(a.des_ctgcom) = upper(b.des_ctgcom)
  
              union all
        
              select distinct a.cod_pers_trs, b.des_contrapartida 
              from (select distinct a.cod_pers_trs, a.cod_comprod, a.des_ctgcom 
                    from da_mariadrav.wallet_bolsa_prod a left join da_mariadrav.productos b
                    on a.cod_pers_trs=b.cod_pers_trs and a.cod_comprod = b.cod_comprod
                    where b.cod_pers_trs is NULL and a.des_ctgcom is not NULL) a
              left join da_mariadrav.relacion_cgtcom_contrapartida b
              on upper(a.des_ctgcom) = upper(b.des_ctgcom)

              union all

              select distinct a.cod_pers_trs, b.des_contrapartida 
              from (select distinct a.cod_pers_trs, a.contrapartida 
                    from da_mariadrav.productos a left join da_mariadrav.wallet_bolsa_prod b
                    on a.cod_pers_trs=b.cod_pers_trs and a.cod_comprod = b.cod_comprod
                    where b.cod_pers_trs is NULL and a.contrapartida is not NULL) a
              right join da_mariadrav.relacion_cgtcom_contrapartida b
              on cast(trim(a.contrapartida) as int) = cast(trim(b.contrapartida) as int)
        ) a 
        right join da_mariadrav.wallet_clientes_bolsa_cuanti b
        on a.cod_pers_trs=b.cod_pers_trs")

```

```{r TABLA_TABLON_ANALISIS, eval=FALSE, echo=FALSE, cache=TRUE}
#** Juntar todas las tablas**
do.hive("create table IF NOT EXISTS da_mariadrav.wallet_tablon_analisis_investigacion as
        select  bolsa.*,
        
                segmcomp.segmento_comportamental,
                segmcomp.mix_actividad,
                segmcomp.frecuencia,
        
                case when tar_stick.num_tar_wallet >0 then 1 else 0 end as ind_tar_wallet,
                case when tar_stick.num_sticker >0 then 1 else 0 end as ind_sticker,
                case when tar_stick.num_habitual >0 then 1 else 0 end as ind_habitual,
                tar_stick.num_tar_wallet,
                tar_stick.num_sticker,
                tar_stick.num_habitual,
                tar_stick.debito_credito as ten_debito_credito,
        
                funcion.hour_soli_trn, 
                funcion.activacion_tarjetas, 
                funcion.bloqueo_tarjetas, 
                funcion.consulta_movim,
                funcion.aplazamiento_pagos, 
                funcion.imp_aplazamiento_pagos, 
                funcion.num_aplazamiento_pagos, 
                funcion.notificaciones_baja,
                funcion.notificaciones_alta, 
                funcion.accion_comercial,
        
                tarjetas.tipo_tarjeta,
                tarjetas.debito_credito,
                tarjetas.num_tarjetas,
                tarjetas.num_movimientos,
                tarjetas.imp_movimientos
        
        from da_mariadrav.wallet_clientes_bolsa_cuanti_partition              bolsa
        
        left join da_mariadrav.wallet_bolsa_segmcomp                          segmcomp
        on bolsa.cod_pers_trs=segmcomp.cod_pers_trs
        
        left join da_mariadrav.wallet_bolsa_tar_stick_num                     tar_stick
        on bolsa.cod_pers_trs=tar_stick.cod_pers_trs
            and bolsa.partition_id=tar_stick.partition_id
        
        left join da_mariadrav.wallet_funcionalidades                        funcion
        on bolsa.cod_pers_trs=funcion.cod_pers_trs 
           and bolsa.partition_id=funcion.partition_id
        
        left join da_mariadrav.wallet_pago_tarjetas                           tarjetas
        on bolsa.cod_pers_trs=tarjetas.cod_pers_trs
          and bolsa.partition_id=tarjetas.partition_id")
``` 


```{r TABLA_TABLON_ANALISIS_AGRUPACION_TIEMPO, eval=FALSE, echo=FALSE, cache=TRUE}
#** Finalmente: Crear la tabla de entrega agrupando los datos históricos **

do.hive("create table IF NOT EXISTS da_mariadrav.wallet_tablon_analisis_investigacion_entrega as
        select  bolsa.*, 
        case when bolsa.antiguedad_wallet_months <= 6 then 1 else 0 end as ant_wallet_menor_6_meses,
        case when bolsa.antiguedad_wallet_months <= 12 then 1 else 0 end as ant_wallet_menor_12_meses,
        segmcomp.segmento_comportamental, segmcomp.mix_actividad, segmcomp.frecuencia,
        tar_stick.ind_tar_wallet, tar_stick.ind_sticker, tar_stick.ind_habitual, 
           tar_stick.num_tar_wallet, tar_stick.num_sticker, tar_stick.num_habitual, tar_stick.ten_debito_credito,
         funcion.hour_soli_trn, funcion.activacion_tarjetas, funcion.bloqueo_tarjetas, funcion.consulta_movim, 
           funcion.aplazamiento_pagos, funcion.imp_aplazamiento_pagos, funcion.num_aplazamiento_pagos,
           funcion.notificaciones_baja, funcion.notificaciones_alta, funcion.accion_comercial,
           funcion.activacion_tarjetas_ult_trim, funcion.bloqueo_tarjetas_ult_trim, funcion.consulta_movim_ult_trim,
           funcion.aplazamiento_pagos_ult_trim, funcion.imp_aplazamiento_pagos_ult_trim, 
           funcion.num_aplazamiento_pagos_ult_trim, funcion.notificaciones_baja_ult_trim, funcion.notificaciones_alta_ult_trim, 
           funcion.accion_comercial_ult_trim,
          tarjetas.tipo_tarjeta, tarjetas.debito_credito, tarjetas.num_tarjetas, tarjetas.num_movimientos, tarjetas.imp_movimientos,
          tarjetas_ult_trim.tipo_tarjeta_ult_trim, tarjetas_ult_trim.debito_credito_ult_trim, 
            tarjetas_ult_trim.num_tarjetas_ult_trim, tarjetas_ult_trim.num_movimientos_ult_trim, 
            tarjetas_ult_trim.imp_movimientos_ult_trim,
          prod.des_contrapartida
        
        from da_mariadrav.wallet_clientes_bolsa_cuanti bolsa
        
        left join 
        
        da_mariadrav.wallet_bolsa_segmcomp  segmcomp
        on bolsa.cod_pers_trs=segmcomp.cod_pers_trs
        
        left join 
        
        (select cod_pers_trs,  max(case when num_tar_wallet >0 then 1 else 0 end) as ind_tar_wallet,
                max(case when num_sticker >0 then 1 else 0 end) as ind_sticker,
                max(case when num_habitual >0 then 1 else 0 end) as ind_habitual,
                avg(num_tar_wallet) as num_tar_wallet,
                avg(num_sticker) as num_sticker,
                avg(num_habitual) as num_habitual,
                debito_credito as ten_debito_credito
         from  da_mariadrav.wallet_bolsa_tar_stick_num  
         where partition_id != '20150430'
         group by cod_pers_trs, debito_credito) tar_stick
        on bolsa.cod_pers_trs=tar_stick.cod_pers_trs
        
        left join 
        
        (select cod_pers_trs, 
                hour_soli_trn,
                max(activacion_tarjetas) as activacion_tarjetas, 
                max(bloqueo_tarjetas) as bloqueo_tarjetas, 
                max(consulta_movim) as consulta_movim,
                max(aplazamiento_pagos) as aplazamiento_pagos,
                avg(imp_aplazamiento_pagos) as imp_aplazamiento_pagos,
                avg(num_aplazamiento_pagos) as num_aplazamiento_pagos,
                max(notificaciones_baja) as notificaciones_baja,
                max(notificaciones_alta) as notificaciones_alta, 
                max(accion_comercial) as accion_comercial,
                max(case when substr(partition_id, 1, 6) in ('201503', '201502', '201501') then activacion_tarjetas else 0 end)
                  as activacion_tarjetas_ult_trim,
                max(case when substr(partition_id, 1, 6) in ('201503', '201502', '201501') then bloqueo_tarjetas else 0 end)
                  as bloqueo_tarjetas_ult_trim,
                max(case when substr(partition_id, 1, 6) in ('201503', '201502', '201501') then consulta_movim else 0 end) 
                  as consulta_movim_ult_trim,
                max(case when substr(partition_id, 1, 6) in ('201503', '201502', '201501') then aplazamiento_pagos else 0 end)
                 as aplazamiento_pagos_ult_trim,
                avg(case when substr(partition_id, 1, 6) in ('201503', '201502', '201501') then imp_aplazamiento_pagos else 0 end)
                 as imp_aplazamiento_pagos_ult_trim,
                avg(case when substr(partition_id, 1, 6) in ('201503', '201502', '201501') then num_aplazamiento_pagos else 0 end)
                 as num_aplazamiento_pagos_ult_trim,
                max(case when substr(partition_id, 1, 6) in ('201503', '201502', '201501') then notificaciones_baja else 0 end) 
                 as notificaciones_baja_ult_trim,
                max(case when substr(partition_id, 1, 6) in ('201503', '201502', '201501') then notificaciones_alta else 0 end)
                 as notificaciones_alta_ult_trim,
                max(case when substr(partition_id, 1, 6) in ('201503', '201502', '201501') then accion_comercial else 0 end) 
                 as accion_comercial_ult_trim
         from da_mariadrav.wallet_funcionalidades
         where partition_id != '20150430'
        group by cod_pers_trs, hour_soli_trn) funcion
        on bolsa.cod_pers_trs=funcion.cod_pers_trs 
        
        left join 
                
        (select *
         from (select cod_pers_trs, tipo_tarjeta, debito_credito, 
               num_tarjetas, num_movimientos, imp_movimientos,
               rank() over (PARTITION BY cod_pers_trs ORDER BY ind_tipo_tarjeta DESC) as rank
               from (select cod_pers_trs, tipo_tarjeta, debito_credito, 
                     avg(num_tarjetas) as num_tarjetas,
                     avg(num_movimientos) as num_movimientos,
                     avg(imp_movimientos) as imp_movimientos,
                     case when tipo_tarjeta is not null then 1 else 0 end as ind_tipo_tarjeta
                     FROM da_mariadrav.wallet_pago_tarjetas
                     where partition_id != '20150430'
                     group by cod_pers_trs, tipo_tarjeta, debito_credito 
                     ) a
                 ) r where rank=1
            ) tarjetas
         
  on bolsa.cod_pers_trs=tarjetas.cod_pers_trs
        
             
        left join 
                
        (select *
         from (select cod_pers_trs, tipo_tarjeta as tipo_tarjeta_ult_trim, debito_credito as debito_credito_ult_trim, 
               num_tarjetas as num_tarjetas_ult_trim, num_movimientos as num_movimientos_ult_trim, 
               imp_movimientos as imp_movimientos_ult_trim,
               rank() over (PARTITION BY cod_pers_trs ORDER BY ind_tipo_tarjeta DESC) as rank
               from (select cod_pers_trs, tipo_tarjeta, debito_credito, 
                     avg(num_tarjetas) as num_tarjetas,
                     avg(num_movimientos) as num_movimientos,
                     avg(imp_movimientos) as imp_movimientos,
                     case when tipo_tarjeta is not null then 1 else 0 end as ind_tipo_tarjeta
                     FROM da_mariadrav.wallet_pago_tarjetas
                     where substr(partition_id, 1, 6) in ('201503', '201502', '201501') 
                     group by cod_pers_trs, tipo_tarjeta, debito_credito 
                     ) a
                 ) r where rank=1
            ) tarjetas_ult_trim
         
 on bolsa.cod_pers_trs=tarjetas_ult_trim.cod_pers_trs
 
        left join 
        
        (select cod_pers_trs, des_contrapartida 
         from da_mariadrav.productos_comb 
        where des_contrapartida is not null) prod
        on bolsa.cod_pers_trs=prod.cod_pers_trs")

```

```{r PRUEBA_SAMPLE, eval=FALSE, echo=FALSE, cache=TRUE}
# sample
SET sampleRate=<sample rate, 0-1>;
select
    field1, field2, field3, ..., fieldN, state
from
    (
    select
        field1, field2, field3, ..., fieldN, state,
        count(*) over (partition by state) as state_cnt,
        rank() over (partition by state order by rand()) as state_rank
    from <table name>
    ) a
where state_rank <= state_cnt*'${hiveconf:sampleRate}'

```

<br/>

# B. Análisis de las variables

<br/>

**1. Estudio variables sociodemográficas:**
<br/> *Análisis Edad, Antigüedad BBVA, Antigüedad Wallet, Género, Ciudad, Segmento según Plan Uno*
<br/> 
<br/>

* Edad: La aplicación se usa por la gente más joven mientras que para edades mayores a 45 años el colectivo Wallet es menor que el de BBVANet. No se aprecia mucha diferencia en las distribuciones de los clientes Activos e Inactivos. 
<br/>

```{r EDAD, eval=TRUE, echo=FALSE, cache=TRUE}
edad <- qhive("select categoria_usuario, cod_edad,
              case when cod_edad>=18 and cod_edad<=24 then '01. 18-24'
                   when cod_edad>=25 and cod_edad<=34 then '02. 24-34'
                   when cod_edad>=35 and cod_edad<=44 then '03. 35-44'
                   when cod_edad>=45 and cod_edad<=59 then '04. 45-59'
                   when cod_edad>=60 then '05. >=60'
               end as grupos_edad,
              count(distinct cod_pers_trs) as conteo_dist_pers
              from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
              group by categoria_usuario, 
                       cod_edad, 
                       case  when cod_edad>=18 and cod_edad<=24 then '01. 18-24'
                             when cod_edad>=25 and cod_edad<=34 then '02. 24-34'
                             when cod_edad>=35 and cod_edad<=44 then '03. 35-44'
                             when cod_edad>=45 and cod_edad<=59 then '04. 45-59'
                             when cod_edad>=60 then '05. >=60'
                         end")

edad$categoria_usuario_ord <- ifelse(edad$categoria_usuario=="Wallet Activo", 
                                                 paste0("01. ", edad$categoria_usuario),
                                                 ifelse(edad$categoria_usuario=="Wallet Inactivo", 
                                                        paste0("02. ", edad$categoria_usuario), 
                                                        paste0("03. ", edad$categoria_usuario)))

ggplot(edad, aes(x=cod_edad)) + geom_histogram( aes(y=conteo_dist_pers), stat="identity", binwidth=.5, colour="white", fill="blue")+ ggtitle("Histograma de la edad x categoría usuario") +  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) + ylab("clientes distintos") + 
    facet_grid(categoria_usuario_ord ~ .)
 
 # Ver la distribución de edad por grupos
edad_gr = unique(ddply(edad, .(grupos_edad, categoria_usuario), transform, conteo_dist_pers_gr = sum(conteo_dist_pers))[, c(1, 3, 6)])

   # Get the levels for type in the required order
edad_gr = arrange(edad_gr, categoria_usuario, grupos_edad)

  # Calculate the percentages
edad_gr = ddply(edad_gr, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers_gr/sum(conteo_dist_pers_gr) * 100)

edad_gr$label_percent_dist_pers = paste0(sprintf("%.0f", edad_gr$percent_dist_pers), "%")

  # Order
edad_gr = edad_gr[order(edad_gr$categoria_usuario, edad_gr$grupos_edad),]

  #Graph
graph_edad_gr <- ggplot(edad_gr, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = grupos_edad, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + geom_bar(stat = "identity", width = .7) + theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) + ylab("clientes distintos") + ggtitle("Grupos edad") + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_edad_gr

```

<br/> 

* Distribución del genero: Los hombres usan más wallet que las mujeres 
<br/> 
```{r GENERO, eval=TRUE, echo=FALSE, cache=TRUE}
sexo <- qhive("select categoria_usuario, xti_sexo, count(distinct cod_pers_trs) as conteo_dist_pers
              from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
              group by categoria_usuario, xti_sexo")

  # Get the levels for type in the required order
sexo = arrange(sexo, categoria_usuario, xti_sexo)

  # Calculate the percentages
sexo = ddply(sexo, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100, pos = cumsum((conteo_dist_pers/sum(conteo_dist_pers)) - (0.5 * conteo_dist_pers/sum(conteo_dist_pers)))*100)

sexo$label_percent_dist_pers = paste0(sprintf("%.0f", sexo$percent_dist_pers), "%")
sexo$des_sexo <- ifelse(sexo$xti_sexo=="M", 'Mujer','Varón')

  # Order
sexo = sexo[order(sexo$categoria_usuario, sexo$xti_sexo),]

  #Graph
graph_sexo <- ggplot(sexo, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = des_sexo, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) + ylab("clientes distintos") +
  ggtitle("Sexo de los Clientes Wallet") + 
  geom_text(aes(y = pos, label = label_percent_dist_pers), position = "stack", size = 3.5)  +
  scale_fill_brewer()
graph_sexo
```

<br/> 

* Provincia / Territorial: Mapa de calor por provincia y % de clientes por territorial 
<br/>

```{r TERRITORIAL_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

  # Heatmap provincia
provincia1 <- qhive("select categoria_usuario, provincia, count(distinct cod_pers_trs) as conteo_dist_pers
              from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
              group by categoria_usuario, provincia")

provincia2 <- qhive("select categoria_usuario, provincia, count(distinct cod_pers_trs) as conteo_dist_pers
              from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
              where trim(upper(provincia)) not like '%MADRID%' and trim(upper(provincia)) not like '%BARCELONA%'
              group by categoria_usuario, provincia")

territorial <- qhive("select categoria_usuario, territorial, count(distinct cod_pers_trs) as conteo_dist_pers
              from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
              group by categoria_usuario, territorial")

```


<br/> 

* * Mapa de calor por provincia (cuanto más claro el color más se usa y cuanto más rojo menos se usa).
<br/>

```{r TERRITORIAL_MAPA_CALOR1, eval=TRUE, echo=FALSE, cache=TRUE}

# Heatmap por provincia
heat_prov1 = arrange(provincia1, categoria_usuario, provincia)

heat_prov1 <- cast(heat_prov1, provincia ~ categoria_usuario, fun.aggregate=sum, value="conteo_dist_pers")

heat_prov1$provincia <- ifelse(is.na(heat_prov1$provincia), 'NA',heat_prov1$provincia)

row.names(heat_prov1) <- heat_prov1$provincia

heat_prov1 <- data.matrix(heat_prov1[,2:4])

par(cex.main=.8) 
heatmap(heat_prov1, Rowv=NA, Colv=NA, col = heat.colors(256), scale="column", margins=c(5,10), cexCol=1, cexRow=0.7, main="Clientes Wallet x provincia")

````

<br/>

* * Un porcentaje muy alto de clientes Wallet se centra en Madrid y Cataluña. Se hace orto mapa de calor centrandonos en el resto de provincias. 
<br/>
```{r TERRITORIAL_MAPA_CALOR2, eval=TRUE, echo=FALSE, cache=TRUE}
# Heatmap por provincia sin Madrid, Barcelona
heat_prov2 = arrange(provincia2, categoria_usuario, provincia)

heat_prov2 <- cast(heat_prov2, provincia ~ categoria_usuario, fun.aggregate=sum, value="conteo_dist_pers")

heat_prov2$provincia <- ifelse(is.na(heat_prov2$provincia), 'NA', heat_prov2$provincia)

row.names(heat_prov2) <- heat_prov2$provincia

heat_prov2 <- data.matrix(heat_prov2[,2:4])

par(cex.main=.8) 
heatmap(heat_prov2, Rowv=NA, Colv=NA, col = heat.colors(256), scale="column", margins=c(5,10), cexCol=1, cexRow=0.7, main="Clientes Wallet x provincia sin Madrid & Cataluña")

```

```{r eval=FALSE , echo=FALSE, cache=TRUE}
# <br/> * * El detalle de clientes por provincias está a continuación: <br/>cast(provincia1, provincia ~ categoria_usuario, fun.aggregate=sum, value="conteo_dist_pers")
```

<br/> 

* * Análisis territorial: 
<br/>
```{r TERRITORIAL_BARS, eval=TRUE, echo=FALSE, cache=TRUE}
  # Baras territorial
 # Get the levels for type in the required order
territorial = arrange(territorial, categoria_usuario, territorial)

  # Calculate the percentages
territorial = ddply(territorial, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100)

territorial$label_percent_dist_pers = paste0(sprintf("%.0f", territorial$percent_dist_pers), "%")

  # Order
territorial = territorial[order(territorial$categoria_usuario, territorial$territorial),]

  #Graph
ggplot(territorial, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = territorial, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) + 
  ylab("clientes distintos") + 
  ggtitle("% Clientes Wallet x Territorial") + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()

```

<br/>

* * A continuación se muestra el detalle de clientes por territorial: 
<br/>
```{r TERRITORIAL_PCT, eval=TRUE, echo=FALSE, cache=TRUE}
territorial <- ddply(territorial, .(categoria_usuario), transform, percent_dist_pers = paste0(sprintf("%.1f", conteo_dist_pers/sum(conteo_dist_pers) * 100), "%"))
cast(territorial[,c(1,2,4)], territorial ~ categoria_usuario)
```

<br/> 

* PlanUno: La aplicación se usa principalmente por los clientes previnculados y transaccionales.
<br/>
```{r PLAN_UNO, eval=TRUE, echo=FALSE, cache=TRUE}
planuno <- qhive("select categoria_usuario, 
                 segm_plan_uno, 
                 case segm_plan_uno when 'P' then 'Vinculado'
                                    when 'R' then 'Basico'
                                    when 'T' then 'Transaccional'
                                    when 'V' then 'Previnculado'
                 end as des_segm_plan_uno,
                 count(distinct cod_pers_trs) as conteo_dist_pers
              from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
              group by categoria_usuario, segm_plan_uno")

#Categoria x planuno
  # Get the levels for type in the required order
planuno = arrange(planuno, categoria_usuario, des_segm_plan_uno)

  # Calculate the percentages
planuno = ddply(planuno, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100)

planuno$label_percent_dist_pers = paste0(sprintf("%.0f", planuno$percent_dist_pers), "%")

  # Order
planuno = planuno[order(planuno$categoria_usuario, planuno$des_segm_plan_uno),]

  #Graph
graph_planuno <- ggplot(planuno, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = des_segm_plan_uno, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) +
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + 
  ggtitle("% Clientes x Segmento PlanUno") + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_planuno

```

<br/>

* Antigüedad en BBVA: La aplicación se usa más por los clientes relativamente nuevos en el Banco. 
<br/>
```{r ANTIGUEDAD_BBVA_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

antig_bbva <- qhive("select categoria_usuario, 
                    antiguedad_months/12 as antiguedad_bbva_years,
                    case when antiguedad_months<=12 then '01. <= 1 año'
                           when antiguedad_months>12 and antiguedad_months<=24 then '02. 1 - 2 años'
                           when antiguedad_months>24 and antiguedad_months<=60 then '03. 2 - 5 años'
                           when antiguedad_months>60 and antiguedad_months<=120 then '04. 5 - 10 años'
                           else '05. > 10 años'
                       end as grupos_antiguedad,
                    count(distinct cod_pers_trs) as conteo_dist_pers
                    from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                    where antiguedad_months>0
                      and antiguedad_months is NOT NULL
                    group by categoria_usuario, antiguedad_months/12,
                    case when antiguedad_months<=12 then '01. <= 1 año'
                           when antiguedad_months>12 and antiguedad_months<=24 then '02. 1 - 2 años'
                           when antiguedad_months>24 and antiguedad_months<=60 then '03. 2 - 5 años'
                           when antiguedad_months>60 and antiguedad_months<=120 then '04. 5 - 10 años'
                           else '05. > 10 años'
                       end")

antig_bbva_hist <- qhive("select distinct cod_pers_trs, categoria_usuario, 
                    antiguedad_months/12 as antiguedad_bbva_years
                    from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                    where antiguedad_months>0
                      and antiguedad_months is NOT NULL")
```

```{r ANTIGUEDAD_BBVA, eval=TRUE, echo=FALSE, cache=TRUE}
antig_bbva_hist$categoria_usuario_ord <- ifelse(antig_bbva_hist$categoria_usuario=="Wallet Activo", 
                                                 paste0("01. ", antig_bbva_hist$categoria_usuario),
                                                 ifelse(antig_bbva_hist$categoria_usuario=="Wallet Inactivo", 
                                                        paste0("02. ", antig_bbva_hist$categoria_usuario), 
                                                        paste0("03. ", antig_bbva_hist$categoria_usuario)))
# Histograma
ggplot(antig_bbva_hist, aes(x=antiguedad_bbva_years)) +
  geom_histogram(  stat="bin", binwidth=1, colour="white", fill="blue") + 
  ggtitle("Histograma de la antigüedad en BBVA (años)") + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) + 
  xlim(0, 30) + 
  ylab("clientes distintos") + 
  facet_grid(categoria_usuario_ord ~ .)

 # Ver la distribución por grupos
  # Get the levels for type in the required order
antig_bbva_gr = arrange(antig_bbva, categoria_usuario, grupos_antiguedad)
antig_bbva_gr = unique(ddply(antig_bbva_gr, .(grupos_antiguedad, categoria_usuario), transform, conteo_dist_pers_gr = sum(conteo_dist_pers))[, c(1, 3, 5)])

  # Calculate the percentages
antig_bbva_gr = ddply(antig_bbva_gr, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers_gr/sum(conteo_dist_pers_gr) * 100, pos = cumsum((conteo_dist_pers_gr/sum(conteo_dist_pers_gr)) - (0.5 * conteo_dist_pers_gr/sum(conteo_dist_pers_gr)))*100)

antig_bbva_gr$label_percent_dist_pers = paste0(sprintf("%.0f", antig_bbva_gr$percent_dist_pers), "%")

  # Order
antig_bbva_gr = antig_bbva_gr[order(antig_bbva_gr$categoria_usuario, antig_bbva_gr$grupos_antiguedad),]

  #Graph
graph_antig_bbva_gr <- ggplot(antig_bbva_gr, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = grupos_antiguedad, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) + 
  ylab("clientes distintos") + 
  ggtitle("Grupos antiguedad en BBVA (años)") + 
  geom_text(aes(y = pos, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_antig_bbva_gr

```

<br/> 

* Distribución de la antigüedad en Wallet: La aplicación se usa más al principio cuando se contrata pero a medida que pase el tiempo se usa menos.
<br/>
```{r ANTIGUEDAD_WALLET_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

antig_wallet <- qhive("select categoria_usuario, 
                      antiguedad_wallet_months,
                      case when antiguedad_wallet_months<=3 then '01. <= 3 meses'
                           when antiguedad_wallet_months>3 and antiguedad_wallet_months<=6 then '02. 3 - 6 meses'
                           when antiguedad_wallet_months>6 and antiguedad_wallet_months<=12 then '03. 6 - 12 meses'
                           else '04. > 12 meses'
                       end as grupos_ant_wall_mon,
                      count(distinct cod_pers_trs) as conteo_dist_pers
                      from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                      where categoria_usuario !='BBVANet' and antiguedad_wallet_months>=0
                      group by categoria_usuario, antiguedad_wallet_months,
                      case when antiguedad_wallet_months<=3 then '01. <= 3 meses'
                           when antiguedad_wallet_months>3 and antiguedad_wallet_months<=6 then '02. 3 - 6 meses'
                           when antiguedad_wallet_months>6 and antiguedad_wallet_months<=12 then '03. 6 - 12 meses'
                           else '04. > 12 meses'
                       end ")
```

```{r ANTIGUEDAD_WALLET, eval=TRUE, echo=FALSE, cache=TRUE}
antig_wallet$categoria_usuario_ord <- ifelse(antig_wallet$categoria_usuario=="Wallet Activo", 
                                                 paste0("01. ", antig_wallet$categoria_usuario),
                                                 ifelse(antig_wallet$categoria_usuario=="Wallet Inactivo", 
                                                        paste0("02. ", antig_wallet$categoria_usuario), 
                                                        paste0("03. ", antig_wallet$categoria_usuario)))
# Histograma
ggplot(antig_wallet, aes(x=antiguedad_wallet_months)) + 
  geom_histogram(aes(y=conteo_dist_pers), stat="identity", binwidth=.5, colour="white", fill="blue") + 
  ggtitle("Histograma de la antigüedad en Wallet (meses)")  + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) +
  ylab("clientes distintos") + 
  facet_grid(categoria_usuario_ord ~ .)


 # Ver la distribución de antigüedad wallet por grupos
antig_wallet_gr = unique(ddply(antig_wallet, .(grupos_ant_wall_mon, categoria_usuario), transform, conteo_dist_pers_gr = sum(conteo_dist_pers))[, c(1, 3, 6)])

   # Get the levels for type in the required order
antig_wallet_gr = arrange(antig_wallet_gr, categoria_usuario, grupos_ant_wall_mon)

  # Calculate the percentages
antig_wallet_gr = ddply(antig_wallet_gr, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers_gr/sum(conteo_dist_pers_gr) * 100)

antig_wallet_gr$label_percent_dist_pers = paste0(sprintf("%.0f", antig_wallet_gr$percent_dist_pers), "%")

  # Order
antig_wallet_gr = antig_wallet_gr[order(antig_wallet_gr$categoria_usuario, antig_wallet_gr$grupos_ant_wall_mon),]

  #Graph
graph_ant_wall_gr <- ggplot(antig_wallet_gr, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = grupos_ant_wall_mon, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) + 
  ylab("clientes distintos") +
  ggtitle("Grupos antigüedad wallet en meses") + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_ant_wall_gr

```

<br/>
**2. Estudio perfil digital:** 
<br/> *franjas horarias de acceso, segmento comportamental, mix_actividad - agrupación del segmento comportamental, frecuencia conexión* 
<br/>

<br/>

* Franjas horarias:
<br/>
```{r FRANJAS, eval=TRUE, echo=FALSE, cache=TRUE}
franjas <- qhive("select distinct categoria_usuario, cod_pers_trs, hour_soli_trn
                 from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                 where categoria_usuario != 'BBNANet'")

# Histograma
ggplot(franjas, aes(x=hour_soli_trn)) + 
  geom_histogram(stat="bin", binwidth=.5, colour="white", fill="blue")  + 
  scale_x_discrete(breaks = seq(0, 24, by = 3)) + 
  ggtitle("Histograma de las franjas horarias de acceso a la aplicación")  + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) +
  ylab("clientes distintos") + 
  facet_grid(categoria_usuario ~ .)

```

<br/>

* Segmento Comportamental:
<br/>
```{r COMPORTAMENTAL_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}
segm_comp <- qhive("select categoria_usuario, 
                   case when segmento_comportamental = 1 then '01. Net contrata'
                   when segmento_comportamental = 2 then '02. Net opera elevado'
                   when segmento_comportamental = 3 then '03. Net opera básico'
                   when segmento_comportamental = 4 then '04. Net consulta ATM elevado'
                   when segmento_comportamental = 5 then '05. Net consulta ATM básico'
                   when segmento_comportamental = 6 then '06. Net consulta'
                   when segmento_comportamental = 7 then '07. ATM avanzado'
                   when segmento_comportamental = 8 then '08. ATM básico'
                   when segmento_comportamental = 9 then '09. Oficina ATM reducido'
                   when segmento_comportamental = 10 then '10. Oficina'
                   when segmento_comportamental = 11 then '11. Poco uso de canales'
                   when segmento_comportamental = 12 then '12. Sin uso'
                   end as segmento_comportamental, 
                   count(distinct cod_pers_trs) as count_dist_pers
                   from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                   group by categoria_usuario, segmento_comportamental")

```

```{r COMPORTAMENTAL, eval=TRUE, echo=FALSE, cache=TRUE}
  # Get the levels for type in the required order
segm_comp = arrange(segm_comp, categoria_usuario, segmento_comportamental)

  # Calculate the percentages
segm_comp = ddply(segm_comp, .(categoria_usuario), transform, percent_dist_pers = count_dist_pers/sum(count_dist_pers) * 100)

segm_comp$label_percent_dist_pers = paste0(sprintf("%.0f", segm_comp$percent_dist_pers), "%")

  # Order
segm_comp = segm_comp[order(segm_comp$segmento_comportamental, segm_comp$categoria_usuario),]

  #Graph
graph_segm_cat <- ggplot(segm_comp, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = segmento_comportamental, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + ggtitle("Segmento comportamental") + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_segm_cat
```

<br/> 

* agrupación segmentos comportamentales:  Los clientes que tienen la app son los que más digitales son... 
<br/>
```{r MIX_ACTIVIDAD_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}
mix_actividad <- qhive("select categoria_usuario, 
                       case when segmento_comportamental = 1 then '01. Compra'
                       when segmento_comportamental = 2 then '02. Transaccional avanzado'
                       when segmento_comportamental = 3 then '03. Transaccional basico' 
                       when segmento_comportamental in (4, 5, 6) then '04. Consultivo'
                       when segmento_comportamental in (7, 8, 9, 10, 11) then '05. Other'
                       when segmento_comportamental = 12 then '12. Sin uso' 
                       end as mix_actividad, 
                       count(distinct cod_pers_trs) as count_dist_pers 
                       from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                       group by categoria_usuario, segmento_comportamental, case when segmento_comportamental = 1 then '01. Compra'
                       when segmento_comportamental = 2 then '02. Transaccional avanzado'
                       when segmento_comportamental = 3 then '03. Transaccional basico' 
                       when segmento_comportamental in (4, 5, 6) then '04. Consultivo'
                       when segmento_comportamental in (7, 8, 9, 10, 11) then '05. Other'
                       when segmento_comportamental = 12 then '12. Sin uso' 
                       end")
```

```{r MIX_ACTIVIDAD, eval=TRUE, echo=FALSE, cache=TRUE}
# Ver la distribución de antigüedad wallet por grupos
mix_actividad = unique(ddply(mix_actividad, .(mix_actividad, categoria_usuario), transform, count_dist_pers = sum(count_dist_pers))[, c(1, 2, 3)])

 # Get the levels for type in the required order
mix_actividad = arrange(mix_actividad, categoria_usuario, mix_actividad )

  # Calculate the percentages
mix_actividad = ddply(mix_actividad, .(categoria_usuario), transform, percent_dist_pers = count_dist_pers/sum(count_dist_pers) * 100)

mix_actividad$label_percent_dist_pers = paste0(sprintf("%.0f", mix_actividad$percent_dist_pers), "%")

  # Order
mix_actividad = mix_actividad[order(mix_actividad$mix_actividad, mix_actividad$categoria_usuario),]

  #Graph
graph_mix_actividad <- ggplot(mix_actividad, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = mix_actividad, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + 
  ggtitle("Grupos segmento comportamental") + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_mix_actividad
```

<br/> 

* frecuencia conexion a canales digitales: ... y usan más a menudo los canales digitales.
<br/>
```{r FREC_ACCESO_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}
frecuencia <- qhive("select categoria_usuario, 
                    case when frecuencia = 'intensivo' then '01. intensivo'
                    when frecuencia = 'semanal' then '02. semanal'
                    when frecuencia = 'mensual' then '03. mensual'
                    when frecuencia = 'trimestral' then '04. trimestral'
                    when frecuencia = 'anual' then '05. anual'
                    end as frecuencia, 
                    count(distinct cod_pers_trs) as count_dist_pers
                    from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                    group by categoria_usuario,  frecuencia")
```

```{r FREC_ACCESO, eval=TRUE, echo=FALSE, cache=TRUE}
 # Get the levels for type in the required order
frecuencia = arrange(frecuencia, categoria_usuario, frecuencia )

  # Calculate the percentages
frecuencia = ddply(frecuencia, .(categoria_usuario), transform, percent_dist_pers = count_dist_pers/sum(count_dist_pers) * 100)
frecuencia$label_percent_dist_pers = paste0(sprintf("%.0f", frecuencia$percent_dist_pers), "%")

  # Order
frecuencia = frecuencia[order(frecuencia$frecuencia, frecuencia$categoria_usuario),]

  #Graph
graph_frecuencia <- ggplot(frecuencia, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = frecuencia, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("% clientes distintos") + 
  ggtitle("Frecuencia de acceso a canales") + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_frecuencia

```

<br/>

**3. Estudio contratación de la tarjeta Wallet o Sticker**
<br/> *Análisis tenencia de tarjeta wallet, Tenencia de sticker, Nº medio de tarjetas activas. (Ver en ANEXO en qué consisten las tarjetas Habituales)* <br/>

```{r TENENCIA_TARJETAS_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}
# Tenencia de tarjeta wallet y de sticker
tar_stick_num <- qhive("select tar.*, clie.num_clientes
                       from ( select categoria_usuario,
                              sum(ind_tar_wallet) as ind_tar_wallet,
                              sum(ind_sticker) as ind_sticker,
                              sum(ind_debito) as ind_debito, 
                              sum(ind_credito) as ind_credito
                              from (select categoria_usuario, cod_pers_trs, 
                                    max(ind_tar_wallet) as ind_tar_wallet, 
                                    max(ind_sticker) as ind_sticker,
                                    max(case when ten_debito_credito ='Debito' then ind_habitual end) as ind_debito,
                                    max(case when ten_debito_credito ='Credito' then ind_habitual end) as ind_credito
                                    from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                                    group by categoria_usuario, cod_pers_trs
                                    ) A
                              group by categoria_usuario
                            ) tar left join 
                            (select categoria_usuario, count(distinct cod_pers_trs) as num_clientes
                            from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                            group by categoria_usuario
                            ) clie
                       on tar.categoria_usuario=clie.categoria_usuario")

# Nº medio de tarjetas activas

tar_stick_mean <- qhive("select categoria_usuario, 
                              cod_pers_trs, sum(num_tar_wallet) as num_tar_wallet, sum(num_sticker) as num_sticker, 
                              sum(case when ten_debito_credito ='Debito' then num_habitual else 0 end) as num_debito,
                              sum(case when ten_debito_credito ='Credito' then num_habitual else 0 end) as num_credito
                              from (select distinct categoria_usuario, cod_pers_trs, num_tar_wallet,
                                    num_sticker, num_habitual, ten_debito_credito 
                                    from da_mariadrav.wallet_tablon_analisis_investigacion_entrega) a
                        group by categoria_usuario, cod_pers_trs")

```

<br/> 

* Tenencia de tarjeta wallet y de sticker 
<br/> 
```{r TENENCIA_TARJETAS, eval=TRUE, echo=FALSE, cache=TRUE}
tar_stick_num<- melt(tar_stick_num, id=c(1,6))
tar_stick_num$variable <- ifelse(tar_stick_num$variable=='ind_tar_wallet', '01. Tarjeta Wallet',
                        ifelse(tar_stick_num$variable=='ind_sticker', '02. Sticker', 
                               ifelse(tar_stick_num$variable=='ind_debito', '04. Débito',
                                      ifelse(tar_stick_num$variable=='ind_credito', '03. Crédito', 'No tenencia'))))


 # Get the levels for type in the required order
tar_stick_num = arrange(tar_stick_num, categoria_usuario, variable )

  # Calculate the percentages
tar_stick_num = ddply(tar_stick_num, .(categoria_usuario), transform, percent_dist_pers = value/num_clientes * 100, pos = cumsum((value/num_clientes) - (0.5 * value/num_clientes))*100)

tar_stick_num$label_percent_dist_pers = paste0(sprintf("%.0f", tar_stick_num$percent_dist_pers), "%")

  # Order
tar_stick_num = tar_stick_num[order(tar_stick_num$variable, tar_stick_num$categoria_usuario),]

  #Graph
graph_tar_stick_num <- ggplot(tar_stick_num, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill=variable, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7, position='dodge') + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + 
  ggtitle("Posesión de Tarjetas") + 
  geom_text(aes(label = label_percent_dist_pers), position = position_dodge(width=0.9), vjust=-0.25, size = 3.5) +
  scale_fill_brewer()
graph_tar_stick_num


```
<br/> 

* Nº medio de tarjetas activas 
<br/>
```{r NUM_TARJETAS, eval=TRUE, echo=FALSE, cache=TRUE}
tar_stick_mean<- melt(tar_stick_mean, c(1,2))
tar_stick_mean<- unique(tar_stick_mean[!is.na(tar_stick_mean$variable),])
tar_stick_mean$tipo_tarjeta <- ifelse(tar_stick_mean$variable=='num_tar_wallet', '01. Tarjeta Wallet',
                                    ifelse(tar_stick_mean$variable=='num_sticker', '02. Sticker', 
                                           ifelse(tar_stick_mean$variable=='num_debito', '04. Débito', '03. Crédito')))

ddply(tar_stick_mean, c("categoria_usuario", "tipo_tarjeta"), summarise,
               N_clientes    = sum(!is.na(value)),
               media         = round(mean(value, na.rm=TRUE), 1),
               mediana       = round(median(value, na.rm=TRUE), 1),
               desv_tipica   = round(sd(value, na.rm=TRUE), 1),
               minimo        = round(min(value, na.rm=TRUE), 0),
               maximo        = round(max(value, na.rm=TRUE), 0)
)


```

<br/> 
**4. Estudio Funcionalidades**
<br/> *Análisis: activación de tarjetas, bloqueo de tarjetas, pago móvil diferenciando si ha sido con o sin sticker, consulta de movimientos, aplazamiento de pagos, recepción de notificaciones, uso de promociones: No se tiene información del uso de promociones sólo de si el cliente recibió alguna promoción Wallet* <br/>
<br/>


```{r FUNCIONALIDADES_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

do.hive("create table if not exists da_mariadrav.funcionalidades_datos as 
        select  cod_pers_trs, categoria_usuario,
        max(activacion_tarjetas) as activacion_tarjetas,
        max(bloqueo_tarjetas) as bloqueo_tarjetas,
        case when max(num_movimientos)> 0 then 1 else 0 end as num_movimientos,
        max(consulta_movim) as consulta_movim,
        max(aplazamiento_pagos) as aplazamiento_pagos,
        max(notificaciones_alta) as notificaciones_alta,
        max(notificaciones_baja) as notificaciones_baja,
        case when max(notificaciones_baja) = 1 or max(notificaciones_alta) = 1 then 1 else 0 end as notificaciones,
        max(accion_comercial) as accion_comercial
        from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
        where categoria_usuario != 'BBVANet'
        group by cod_pers_trs, categoria_usuario")
              
do.hive("create table if not exists da_mariadrav.funcionalidades_datos_activos as 
        select cod_pers_trs,
        max(activacion_tarjetas_ult_trim) as activacion_tarjetas,
        max(bloqueo_tarjetas_ult_trim) as bloqueo_tarjetas,
        case when max(num_movimientos_ult_trim)> 0 then 1 else 0 end as num_movimientos,
        max(consulta_movim_ult_trim) as consulta_movim,
        max(aplazamiento_pagos_ult_trim) as aplazamiento_pagos,
        max(notificaciones_alta_ult_trim) as notificaciones_alta,
        max(notificaciones_baja_ult_trim) as notificaciones_baja,
        case when max(notificaciones_baja_ult_trim) = 1 or max(notificaciones_alta_ult_trim) = 1 then 1 else 0 end as notificaciones,
        max(accion_comercial_ult_trim) as accion_comercial
        from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
        where categoria_usuario = 'Wallet Activo'
        group by cod_pers_trs")
              
```

4.1. Activación de tarjetas: Es una opción que se usa más por los activos. Un 31% de ellos la usó en algún momento desde el alta en wallet y de ellos un 10% la usó en el último trimestre.

```{r ACTIVACION_TARJETAS_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

activacion_tarjetas <- qhive("select categoria_usuario,
                             case when activacion_tarjetas = 1 then 'Sí' else 'No' 
                             end as resumen_activacion_tarjetas,
                             count(cod_pers_trs) as conteo_dist_pers
                             from da_mariadrav.funcionalidades_datos
                             group by categoria_usuario, case when activacion_tarjetas = 1 then 'Sí' else 'No' end")

activacion_tarjetas_activos <- qhive("select case when activacion_tarjetas = 1 then 'Sí' else 'No' 
                                             end as resumen_activacion_tarjetas,
                                     count(distinct cod_pers_trs) as conteo_dist_pers
                                     from da_mariadrav.funcionalidades_datos_activos 
                                     group by case when activacion_tarjetas = 1 then 'Sí' else 'No' end")
              
```

```{r ACTIVACION_TARJETAS, eval=TRUE, echo=FALSE, cache=TRUE}
#Gráfico 
 # Get the levels for type in the required order
activacion_tarjetas = arrange(activacion_tarjetas, categoria_usuario, resumen_activacion_tarjetas )

  # Calculate the percentages
activacion_tarjetas = ddply(activacion_tarjetas, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100, pos = cumsum((conteo_dist_pers/sum(conteo_dist_pers)) - (0.5 * conteo_dist_pers/sum(conteo_dist_pers)))*100)

activacion_tarjetas$label_percent_dist_pers = paste0(sprintf("%.0f", activacion_tarjetas$percent_dist_pers), "%")

  # Order
activacion_tarjetas = activacion_tarjetas[order(activacion_tarjetas$resumen_activacion_tarjetas, activacion_tarjetas$categoria_usuario),]

  #Graph
graph_activacion_tarjetas <- ggplot(activacion_tarjetas, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = resumen_activacion_tarjetas, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + 
  ggtitle("Activación de tarjetas en la app") + 
  geom_text(aes(y = pos, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_activacion_tarjetas

#Gráfico en el último trimestre
  # Calculate the percentages
activacion_tarjetas_activos$percent_dist_pers = activacion_tarjetas_activos$conteo_dist_pers/sum(activacion_tarjetas_activos$conteo_dist_pers) * 100
activacion_tarjetas_activos$label_percent_dist_pers = paste0(sprintf("%.0f", activacion_tarjetas_activos$percent_dist_pers), "%")

  #Graph
graph_activacion_tarjetas_activos <- ggplot(activacion_tarjetas_activos, aes(x = resumen_activacion_tarjetas, y = percent_dist_pers, label=label_percent_dist_pers, ymax=(max(percent_dist_pers)+0.1*max(percent_dist_pers)))) + 
  geom_bar(stat = "identity", width = .7, fill='blue') + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + 
  ggtitle(expression(atop(paste('Activación de tarjetas en la app'), atop(italic(paste('Clientes Wallet Activos, último trimestre')), "")))) + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5, vjust=-2) +
  scale_fill_brewer()
graph_activacion_tarjetas_activos

```

<br/> 

4.2. Bloqueo de tarjetas: Se usa por el 32% de los activos y 19% de los inactivos. <br/>
```{r BLOQUEO_TARJETAS_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

bloqueo_tarjetas <- qhive("select categoria_usuario,
                             case when bloqueo_tarjetas = 1 then 'Sí' else 'No' 
                             end as resumen_bloqueo_tarjetas,
                             count(cod_pers_trs) as conteo_dist_pers
                             from da_mariadrav.funcionalidades_datos
                             group by categoria_usuario, case when bloqueo_tarjetas = 1 then 'Sí' else 'No' end")

bloqueo_tarjetas_activos <- qhive("select case when bloqueo_tarjetas = 1 then 'Sí' else 'No' 
                                             end as resumen_bloqueo_tarjetas,
                                     count(distinct cod_pers_trs) as conteo_dist_pers
                                     from da_mariadrav.funcionalidades_datos_activos 
                                     group by case when bloqueo_tarjetas = 1 then 'Sí' else 'No' end")

```


```{r BLOQUEO_TARJETAS, eval=TRUE, echo=FALSE, cache=TRUE}
#Gráfico 
 # Get the levels for type in the required order
bloqueo_tarjetas = arrange(bloqueo_tarjetas, categoria_usuario, resumen_bloqueo_tarjetas)

  # Calculate the percentages
bloqueo_tarjetas = ddply(bloqueo_tarjetas, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100, pos = cumsum((conteo_dist_pers/sum(conteo_dist_pers)) - (0.5 * conteo_dist_pers/sum(conteo_dist_pers)))*100)
bloqueo_tarjetas$label_percent_dist_pers = paste0(sprintf("%.0f", bloqueo_tarjetas$percent_dist_pers), "%")

  # Order
bloqueo_tarjetas = bloqueo_tarjetas[order(bloqueo_tarjetas$resumen_bloqueo_tarjetas, bloqueo_tarjetas$categoria_usuario),]

  #Graph
graph_bloqueo_tarjetas <- ggplot(bloqueo_tarjetas, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = resumen_bloqueo_tarjetas, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + 
  ggtitle("Bloqueo de tarjetas en la app") + 
  geom_text(aes(y = pos, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_bloqueo_tarjetas


#Gráfico en el último trimestre
  # Calculate the percentages
bloqueo_tarjetas_activos$percent_dist_pers = bloqueo_tarjetas_activos$conteo_dist_pers/sum(bloqueo_tarjetas_activos$conteo_dist_pers) * 100
bloqueo_tarjetas_activos$label_percent_dist_pers = paste0(sprintf("%.0f", bloqueo_tarjetas_activos$percent_dist_pers), "%")

  #Graph
graph_bloqueo_tarjetas_activos <- ggplot(bloqueo_tarjetas_activos, aes(x = resumen_bloqueo_tarjetas, y = percent_dist_pers, label=label_percent_dist_pers, ymax=(max(percent_dist_pers)+0.1*max(percent_dist_pers)))) + 
  geom_bar(stat = "identity", width = .7, fill='blue') + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + 
  ggtitle(expression(atop(paste('Bloqueo de tarjetas en la app'), atop(italic(paste('Clientes Wallet Activos, último trimestre')), "")))) + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5, vjust=-2) +
  scale_fill_brewer()
graph_bloqueo_tarjetas_activos

```

<br/> 

4.3. Pago móvil, diferenciando si ha sido con o sin sticker o si con una tarjeta habitual. Las habituales figuran con dos valores: tarjeta de crédito o tarjeta de débito. <br/> 

```{r PAGO_MOVIL_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

############################ PAGO MOVIL ############################################

pago_movil<- qhive("select categoria_usuario, 
                   case when tipo_tarjeta='Habitual' then debito_credito
                        when tipo_tarjeta is not NULL then tipo_tarjeta
                        else 'No pagos'
                   end as tipo_tarjeta,
                   count(distinct cod_pers_trs) as conteo_dist_pers
                   from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                     group by categoria_usuario, 
                   case when tipo_tarjeta='Habitual' then debito_credito
                        when tipo_tarjeta is not NULL then tipo_tarjeta
                        else 'No pagos'
                   end")

pago_movil_activos<- qhive("select case when tipo_tarjeta_ult_trim != '' then tipo_tarjeta_ult_trim else 'No pagos' end as tipo_tarjeta, debito_credito_ult_trim as debito_credito,
                    count(distinct cod_pers_trs) as conteo_dist_pers
                    from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                     where categoria_usuario = 'Wallet Activo'
                    group by case when tipo_tarjeta_ult_trim != '' then tipo_tarjeta_ult_trim else 'No pagos' end, debito_credito_ult_trim")

############################ NUMERO MEDIO TARJETAS ############################################
num_tarjetas <- qhive("select categoria_usuario, cod_pers_trs,
                   case when tipo_tarjeta='Habitual' then debito_credito
                        when tipo_tarjeta is not NULL then tipo_tarjeta
                        else 'No pagos'
                   end as tipo_tarjeta,
                   avg(num_tarjetas) as num_tarjetas
                   from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                   group by categoria_usuario, cod_pers_trs,
                   case when tipo_tarjeta='Habitual' then debito_credito
                        when tipo_tarjeta is not NULL then tipo_tarjeta
                        else 'No pagos'
                   end")

############################ NUMERO MOVIMIENTOS ############################################
num_movimientos <- qhive("select categoria_usuario, cod_pers_trs,
                   case when tipo_tarjeta='Habitual' then debito_credito
                        when tipo_tarjeta is not NULL then tipo_tarjeta
                        else 'No pagos'
                   end as tipo_tarjeta,
                   avg(num_movimientos) as num_movimientos
                   from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                   group by categoria_usuario, cod_pers_trs,
                   case when tipo_tarjeta='Habitual' then debito_credito
                        when tipo_tarjeta is not NULL then tipo_tarjeta
                        else 'No pagos'
                   end")

############################ IMPORTE MOVIMIENTOS ############################################

imp_movimientos <- qhive("select categoria_usuario, cod_pers_trs,
                   case when tipo_tarjeta='Habitual' then debito_credito
                        when tipo_tarjeta is not NULL then tipo_tarjeta
                        else 'No pagos'
                   end as tipo_tarjeta,
                   avg(imp_movimientos) as imp_movimientos
                   from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                   group by categoria_usuario, cod_pers_trs,
                   case when tipo_tarjeta='Habitual' then debito_credito
                        when tipo_tarjeta is not NULL then tipo_tarjeta
                        else 'No pagos'
                   end")

```

```{r PAGO_MOVIL, eval=TRUE, echo=FALSE, cache=TRUE}
############################ PAGO MOVIL ############################################
#Gráfico 
pago_movil$tipo_tarjeta <- ifelse(pago_movil$tipo_tarjeta=='Tarjeta Wallet', '01. Tarjeta Wallet',
                                  ifelse(pago_movil$tipo_tarjeta=='Sticker', '02. Sticker',
                                         ifelse(pago_movil$tipo_tarjeta=='Credito', '03. Crédito',
                                                ifelse(pago_movil$tipo_tarjeta=='Debito', '04. Débito', '05. No pagos'))))

 # Get the levels for type in the required order
pago_movil = arrange(pago_movil, categoria_usuario, tipo_tarjeta )

  # Calculate the percentages
pago_movil = ddply(pago_movil, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100, pos = cumsum((conteo_dist_pers/sum(conteo_dist_pers)) - (0.5 * conteo_dist_pers/sum(conteo_dist_pers)))*100)

pago_movil$label_percent_dist_pers = paste0(sprintf("%.0f", pago_movil$percent_dist_pers), "%")

  # Order
pago_movil = pago_movil[order(pago_movil$tipo_tarjeta, pago_movil$categoria_usuario),]

  #Graph
graph_pago_movil <- ggplot(pago_movil, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill=tipo_tarjeta, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7, position='dodge') + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + 
  ggtitle("Pago móvil") + 
  geom_text(aes(label = label_percent_dist_pers), position = position_dodge(width=0.9), vjust=-0.25, size = 3.5) +
  scale_fill_brewer()
graph_pago_movil


#Gráfico en el último trimestre
pago_movil_activos$tipo_tarjeta=ifelse(pago_movil_activos$tipo_tarjeta=='Tarjeta Wallet', '01. Tarjeta Wallet',
                               ifelse(pago_movil_activos$tipo_tarjeta=='Sticker', '02. Sticker',
                                      ifelse(pago_movil_activos$tipo_tarjeta=='Habitual' & pago_movil_activos$debito_credito == 'Credito', '03. Crédito',
                                             ifelse(pago_movil_activos$tipo_tarjeta=='Habitual' & pago_movil_activos$debito_credito == 'Debito', '04. Débito','05. No pagos'))))

  # Calculate the percentages
pago_movil_activos$percent_dist_pers = pago_movil_activos$conteo_dist_pers/sum(pago_movil_activos$conteo_dist_pers) * 100
pago_movil_activos$label_percent_dist_pers = paste0(sprintf("%.0f", pago_movil_activos$percent_dist_pers), "%")

  #Graph
graph_pago_movil_activos <- ggplot(pago_movil_activos, aes(x = tipo_tarjeta, y = percent_dist_pers, label=label_percent_dist_pers, ymax=(max(percent_dist_pers)+0.1*max(percent_dist_pers)))) + 
  geom_bar(stat = "identity", width = .7, fill='blue') + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + 
  ggtitle(expression(atop(paste('Tipo de tarjeta que usa en la app'), atop(italic(paste('Clientes Wallet Activos, último trimestre')), "")))) + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5, vjust=-2) +
  scale_fill_brewer()
graph_pago_movil_activos

```

<br/> 

* Número medio de tarjetas por tipo de tarjeta <br/> 
```{r PAGO_MOVIL_NUM_TARJETAS, eval=TRUE, echo=FALSE, cache=TRUE}
############################ NUMERO TARJETAS ############################################
num_tarjetas$tipo_tarjeta=ifelse(num_tarjetas$tipo_tarjeta=='Tarjeta Wallet', '01. Tarjeta Wallet',
                                  ifelse(num_tarjetas$tipo_tarjeta=='Sticker', '02. Sticker',
                                         ifelse(num_tarjetas$tipo_tarjeta=='Credito', '03. Crédito',
                                                ifelse(num_tarjetas$tipo_tarjeta=='Debito', '04. Débito', '05. No pagos'))))

ddply(num_tarjetas, c("categoria_usuario", "tipo_tarjeta"), summarise,
               N_clientes    = sum(!is.na(num_tarjetas)),
               media         = round(mean(num_tarjetas, na.rm=TRUE), 1),
               mediana       = round(median(num_tarjetas, na.rm=TRUE), 1),
               desv_tipica   = round(sd(num_tarjetas, na.rm=TRUE), 1),
               minimo        = round(min(num_tarjetas, na.rm=TRUE), 0),
               maximo        = round(max(num_tarjetas, na.rm=TRUE), 0)
)

```

<br/>

* Número medio de movimientos por tipo de tarjeta <br/> 
```{r PAGO_MOVIL_NUM_MOVIMIENTOS, eval=TRUE, echo=FALSE, cache=TRUE}
############################ NUMERO MOVIMIENTOS ############################################
num_movimientos$tipo_tarjeta=ifelse(num_movimientos$tipo_tarjeta=='Tarjeta Wallet', '01. Tarjeta Wallet',
                                  ifelse(num_movimientos$tipo_tarjeta=='Sticker', '02. Sticker',
                                         ifelse(num_movimientos$tipo_tarjeta=='Credito', '03. Crédito',
                                                ifelse(num_movimientos$tipo_tarjeta=='Debito', '04. Débito', '05. No pagos'))))

ddply(num_movimientos, c("categoria_usuario", "tipo_tarjeta"), summarise,
               N_clientes    = sum(!is.na(num_movimientos)),
               media         = round(mean(num_movimientos, na.rm=TRUE), 1),
               mediana       = round(median(num_movimientos, na.rm=TRUE), 1),
               desv_tipica   = round(sd(num_movimientos, na.rm=TRUE), 1),
               minimo        = round(min(num_movimientos, na.rm=TRUE), 1),
               maximo           = round(max(num_movimientos, na.rm=TRUE), 1)
)


```

<br/> 

* Importe medio por tipo de tarjeta <br/> 
```{r PAGO_MOVIL_IMP_MOVIMIENTOS, eval=TRUE, echo=FALSE, fig.width=10, fig.height=8, cache=TRUE}
############################ IMPORTE MOVIMIENTOS ############################################

# Histograma
ggplot(imp_movimientos[imp_movimientos$tipo_tarjeta != 'No pagos',], aes(x=imp_movimientos)) + 
  geom_histogram(  stat="bin", binwidth=30, colour="white", fill="blue") + 
  ggtitle("Histograma de los importes por tipo de tarjeta y usuario") + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) + 
  xlim(0, 1200) + 
  ylab("clientes distintos") + 
  facet_grid(categoria_usuario ~ tipo_tarjeta)



imp_movimientos$tipo_tarjeta=ifelse(imp_movimientos$tipo_tarjeta=='Tarjeta Wallet', '01. Tarjeta Wallet',
                                  ifelse(imp_movimientos$tipo_tarjeta=='Sticker', '02. Sticker',
                                         ifelse(imp_movimientos$tipo_tarjeta=='Credito', '03. Crédito',
                                                ifelse(imp_movimientos$tipo_tarjeta=='Debito', '04. Débito', '05. No pagos'))))

ddply(imp_movimientos[imp_movimientos$tipo_tarjeta != 'No pagos',], c("categoria_usuario", "tipo_tarjeta"), summarise,
               N_clientes    = sum(!is.na(imp_movimientos)),
               media         = paste0(round(mean(imp_movimientos, na.rm=TRUE), 0)," €"),
               mediana       = paste0(round(median(imp_movimientos, na.rm=TRUE), 0)," €"),
               desv_tipica   = paste0(round(sd(imp_movimientos, na.rm=TRUE), 0)," €"),
               minimo        = paste0(round(min(imp_movimientos, na.rm=TRUE), 0)," €"),
               maximo        = paste0(round(max(imp_movimientos, na.rm=TRUE), 0)," €")
)

```   

<br/> 

4.4. Consulta de movimientos: Es la opción más utilizada. El 72% de los activos la han usado y el 54% de ellos la usaron en el último trimestre. El 48% de los que ahora son inactivos usaron esta opción en algún momento. <br/>
```{r CONSULTA_MOVIMIENTOS_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}
consulta_movim <- qhive("select categoria_usuario,
                             case when consulta_movim = 1 then 'Sí' else 'No' 
                             end as resumen_consulta_movim,
                             count(cod_pers_trs) as conteo_dist_pers
                             from da_mariadrav.funcionalidades_datos
                             group by categoria_usuario, case when consulta_movim = 1 then 'Sí' else 'No' end")

consulta_movim_activos <- qhive("select case when consulta_movim = 1 then 'Sí' else 'No' 
                                             end as resumen_consulta_movim,
                                     count(distinct cod_pers_trs) as conteo_dist_pers
                                     from da_mariadrav.funcionalidades_datos_activos 
                                     group by case when consulta_movim = 1 then 'Sí' else 'No' end")

```

```{r CONSULTA_MOVIMIENTOS, eval=TRUE, echo=FALSE, cache=TRUE}
#Gráfico 
  # Get the levels for type in the required order
consulta_movim = arrange(consulta_movim, categoria_usuario, resumen_consulta_movim)

  # Calculate the percentages
consulta_movim = ddply(consulta_movim, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100, pos = cumsum((conteo_dist_pers/sum(conteo_dist_pers)) - (0.5 * conteo_dist_pers/sum(conteo_dist_pers)))*100)

consulta_movim$label_percent_dist_pers = paste0(sprintf("%.0f", consulta_movim$percent_dist_pers), "%")

  # Order
consulta_movim = consulta_movim[order(consulta_movim$resumen_consulta_movim, consulta_movim$categoria_usuario),]

  #Graph
graph_consulta_movim <- ggplot(consulta_movim, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = resumen_consulta_movim, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("% clientes distintos") + 
  ggtitle("Consulta de movimientos en la app") + 
  geom_text(aes(y = pos, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_consulta_movim

#Gráfico en el último trimestre
  # Calculate the percentages
consulta_movim_activos$percent_dist_pers = consulta_movim_activos$conteo_dist_pers/sum(consulta_movim_activos$conteo_dist_pers) * 100
consulta_movim_activos$label_percent_dist_pers = paste0(sprintf("%.0f", consulta_movim_activos$percent_dist_pers), "%")

  #Graph
graph_consulta_movim_activos <- ggplot(consulta_movim_activos, aes(x = resumen_consulta_movim, y = percent_dist_pers, label=label_percent_dist_pers, ymax=(max(percent_dist_pers)+0.1*max(percent_dist_pers)))) + 
  geom_bar(stat = "identity", width = .7, fill='blue') + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("% clientes distintos") + 
  ggtitle(expression(atop(paste('Consulta de movimientos en la app'), atop(italic(paste('Clientes Wallet Activos, último trimestre')), "")))) + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5, vjust=-2) +
  scale_fill_brewer()
graph_consulta_movim_activos

```

<br/> 

4.5. Aplazamiento de pagos: Sólo el 2% de lso activos han usado esta opción en algún momento. <br/>
```{r APLAZAMIENTO_PAGOS_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

############################ APLAZAMIENTO PAGOS ############################################
aplazamiento_pagos <- qhive("select categoria_usuario,
                             case when aplazamiento_pagos = 1 then 'Sí' else 'No' 
                             end as resumen_aplazamiento_pagos,
                             count(cod_pers_trs) as conteo_dist_pers
                             from da_mariadrav.funcionalidades_datos
                             group by categoria_usuario, case when aplazamiento_pagos = 1 then 'Sí' else 'No' end")

aplazamiento_pagos_activos <- qhive("select case when aplazamiento_pagos = 1 then 'Sí' else 'No' 
                                             end as resumen_aplazamiento_pagos,
                                     count(distinct cod_pers_trs) as conteo_dist_pers
                                     from da_mariadrav.funcionalidades_datos_activos 
                                     group by case when aplazamiento_pagos = 1 then 'Sí' else 'No' end")

############################ NUMERO APLAZAMIENTO PAGOS ############################################
num_aplazamiento_pagos <- qhive("select categoria_usuario, cod_pers_trs,
                                 sum(num_aplazamiento_pagos) as num_aplazamiento_pagos
                                 from (select distinct categoria_usuario, cod_pers_trs,
                                        num_aplazamiento_pagos, hour_soli_trn 
                                      from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                                      where aplazamiento_pagos=1
                                        and categoria_usuario != 'BBVANet'
                                      ) a
                                 group by categoria_usuario, cod_pers_trs")

############################ IMPORTE APLAZAMIENTO PAGOS ############################################

imp_aplazamiento_pagos <- qhive("select categoria_usuario, cod_pers_trs,
                         sum(imp_aplazamiento_pagos) as imp_aplazamiento_pagos
                         from ( select distinct categoria_usuario, cod_pers_trs, 
                                imp_aplazamiento_pagos, hour_soli_trn 
                                from da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                                where aplazamiento_pagos=1
                                  and categoria_usuario != 'BBVANet'
                              ) a
                         group by categoria_usuario, cod_pers_trs")
              
```

```{r APLAZAMIENTO_PAGOS, eval=TRUE, echo=FALSE, cache=TRUE}
#Gráfico
 # Get the levels for type in the required order
aplazamiento_pagos = arrange(aplazamiento_pagos, categoria_usuario, resumen_aplazamiento_pagos)

  # Calculate the percentages
aplazamiento_pagos = ddply(aplazamiento_pagos, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100, pos = cumsum((conteo_dist_pers/sum(conteo_dist_pers)) - (0.5 * conteo_dist_pers/sum(conteo_dist_pers)))*100)
aplazamiento_pagos$label_percent_dist_pers = paste0(sprintf("%.0f", aplazamiento_pagos$percent_dist_pers), "%")

  # Order
aplazamiento_pagos = aplazamiento_pagos[order(aplazamiento_pagos$resumen_aplazamiento_pagos, aplazamiento_pagos$categoria_usuario),]

  #Graph
graph_aplazamiento_pagos <- ggplot(aplazamiento_pagos, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = resumen_aplazamiento_pagos, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("% clientes distintos") + 
  ggtitle("Aplazamiento de pagos en la app") + 
  geom_text(aes(y = pos, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_aplazamiento_pagos

#Gráfico en el último trimestre
  # Calculate the percentages
aplazamiento_pagos_activos$percent_dist_pers = aplazamiento_pagos_activos$conteo_dist_pers/sum(aplazamiento_pagos_activos$conteo_dist_pers) * 100
aplazamiento_pagos_activos$label_percent_dist_pers = paste0(sprintf("%.0f", aplazamiento_pagos_activos$percent_dist_pers), "%")

  #Graph
graph_aplazamiento_pagos_activos <- ggplot(aplazamiento_pagos_activos, aes(x = resumen_aplazamiento_pagos, y = percent_dist_pers, label=label_percent_dist_pers, ymax=(max(percent_dist_pers)+0.1*max(percent_dist_pers)))) + 
  geom_bar(stat = "identity", width = .7, fill='blue') + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("% clientes distintos") + 
  ggtitle(expression(atop(paste('Aplazamiento de pagos en la app'), atop(italic(paste('Clientes Wallet Activos, último trimestre')), "")))) + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5, vjust=-2) +
  scale_fill_brewer()
graph_aplazamiento_pagos_activos

```


<br/>

* Número medio de aplazamiento de pagos (entre los clientes que usaron esta funcionalidad) <br/> 
```{r APLAZAMIENTO_PAGOS_NUM, eval=TRUE, echo=FALSE, cache=TRUE}
############################ NUMERO APLAZAMIENTOS ############################################

ddply(num_aplazamiento_pagos, c("categoria_usuario"), summarise,
               N_clientes    = sum(!is.na(num_aplazamiento_pagos)),
               media         = round(mean(num_aplazamiento_pagos, na.rm=TRUE), 1),
               mediana       = round(median(num_aplazamiento_pagos, na.rm=TRUE), 1),
               desv_tipica   = round(sd(num_aplazamiento_pagos, na.rm=TRUE), 1),
               minimo        = round(min(num_aplazamiento_pagos, na.rm=TRUE), 1),
               maximo           = round(max(num_aplazamiento_pagos, na.rm=TRUE), 1)
)


```

<br/> 

* Importe medio de aplazamiento de pagos (entre los clientes que usaron esta funcionalidad) <br/> 
```{r APLAZAMIENTO_PAGOS_IMP, eval=TRUE, echo=FALSE, fig.width=10, fig.height=6, cache=TRUE}
############################ IMPORTE APLAZAMIENTOS ############################################

# Histograma
ggplot(imp_aplazamiento_pagos, aes(x=imp_aplazamiento_pagos)) + 
  geom_histogram(  stat="bin", binwidth=30, colour="white", fill="blue") + 
  ggtitle("Histograma de los importes por categoria de usuario") + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10)) + 
  xlim(0, 1200) + 
  ylab("clientes distintos") + 
  facet_grid(~ categoria_usuario )


ddply(imp_aplazamiento_pagos, c("categoria_usuario"), summarise,
               N_clientes    = sum(!is.na(imp_aplazamiento_pagos)),
               media         = paste0(round(mean(imp_aplazamiento_pagos, na.rm=TRUE), 0)," €"),
               mediana       = paste0(round(median(imp_aplazamiento_pagos, na.rm=TRUE), 0)," €"),
               desv_tipica   = paste0(round(sd(imp_aplazamiento_pagos, na.rm=TRUE), 0)," €"),
               minimo        = paste0(round(min(imp_aplazamiento_pagos, na.rm=TRUE), 0)," €"),
               maximo        = paste0(round(max(imp_aplazamiento_pagos, na.rm=TRUE), 0)," €")
)

```   

<br/> 

4.6. Notificaciones (solicitud de alta / baja en el servicio de notificaciones): El servicio de alta de notificaciones se usa por el 97% de los clientes Activos en Wallet. El 73% de los clientes inactivos Wallet usaron este servicio alguna vez. El 59% de los activos usaron el alta de notificaciones en el último trimestre. <br/>

```{r NOTIFICACIONES_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

notificaciones <- qhive("select categoria_usuario,
                        case when notificaciones_alta = 1 and notificaciones_baja = 1 then 'Alta & Baja'
                             when notificaciones_alta = 1 then 'Alta'
                             when notificaciones_baja = 1 then 'Baja'
                             else 'No' 
                        end as resumen_alta_baja,   
                        count(distinct cod_pers_trs) as conteo_dist_pers
                        from da_mariadrav.funcionalidades_datos
                        group by categoria_usuario, case when notificaciones_alta = 1 and notificaciones_baja = 1 then 'Alta & Baja' when notificaciones_alta = 1 then 'Alta' when notificaciones_baja = 1 then 'Baja' else 'No' end")

notificaciones_activos <- qhive("select case when notificaciones_alta = 1 and notificaciones_baja = 1 then 'Alta & Baja'
                             when notificaciones_alta = 1 then 'Alta'
                             when notificaciones_baja = 1 then 'Baja'
                             else 'No' 
                        end as resumen_alta_baja,   
                        count(distinct cod_pers_trs) as conteo_dist_pers
                        from da_mariadrav.funcionalidades_datos_activos
                        group by case when notificaciones_alta = 1 and notificaciones_baja = 1 then 'Alta & Baja' when notificaciones_alta = 1 then 'Alta' when notificaciones_baja = 1 then 'Baja' else 'No' end")
   
```

```{r NOTIFICACIONES, eval=TRUE, echo=FALSE, cache=TRUE}
#Gráfico
 # Get the levels for type in the required order
notificaciones = arrange(notificaciones, categoria_usuario, resumen_alta_baja)

  # Calculate the percentages
notificaciones = ddply(notificaciones, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100, pos = cumsum((conteo_dist_pers/sum(conteo_dist_pers)) - (0.5 * conteo_dist_pers/sum(conteo_dist_pers)))*100)


notificaciones$label_percent_dist_pers = paste0(sprintf("%.0f", notificaciones$percent_dist_pers), "%")

  # Order
notificaciones = notificaciones[order(notificaciones$resumen_alta_baja, notificaciones$categoria_usuario),]

  #Graph
graph_notificaciones <- ggplot(notificaciones, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = resumen_alta_baja, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("% clientes distintos") + 
  ggtitle("Alta / Baja notificaciones en la app") + 
  geom_text(aes(label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_notificaciones


#Gráfico en el último trimestre
  # Calculate the percentages
notificaciones_activos$percent_dist_pers = notificaciones_activos$conteo_dist_pers/sum(notificaciones_activos$conteo_dist_pers) * 100
notificaciones_activos$label_percent_dist_pers = paste0(sprintf("%.0f", notificaciones_activos$percent_dist_pers), "%")

  #Graph
graph_notificaciones_activos <- ggplot(notificaciones_activos, aes(x = resumen_alta_baja, y = percent_dist_pers, label=label_percent_dist_pers, ymax=(max(percent_dist_pers)+0.1*max(percent_dist_pers)))) + 
  geom_bar(stat = "identity", width = .7, fill='blue') + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("% clientes distintos") + 
  ggtitle(expression(atop(paste('Alta / Baja notificaciones en la app'), atop(italic(paste('Clientes Wallet Activos, último trimestre')), "")))) + 
  geom_text(aes(y = percent_dist_pers, label = label_percent_dist_pers), position = "stack", size = 3.5, vjust=-2) +
  scale_fill_brewer()
graph_notificaciones_activos

```

<br/> 

4.7. acción comercial Wallet: El 68% de los activos y el 69% de los inactivos recibieron en algún momento alguna campaña wallet. Ninguno de los activos recibió campañas en el último trimestre. <br/> 
```{r ACCION_COMERCIAL_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

accion_comercial <- qhive("select categoria_usuario,
                             case when accion_comercial = 1 then 'Sí' else 'No' 
                             end as resumen_accion_comercial,
                             count(cod_pers_trs) as conteo_dist_pers
                             from da_mariadrav.funcionalidades_datos
                             group by categoria_usuario, case when accion_comercial = 1 then 'Sí' else 'No' end")

accion_comercial_activos <- qhive("select case when accion_comercial = 1 then 'Sí' else 'No' 
                                             end as resumen_accion_comercial,
                                     count(distinct cod_pers_trs) as conteo_dist_pers
                                     from da_mariadrav.funcionalidades_datos_activos 
                                     group by case when accion_comercial = 1 then 'Sí' else 'No' end")
```

```{r ACCION_COMERCIAL, eval=TRUE, echo=FALSE, cache=TRUE}
#Gráfico
 # Get the levels for type in the required order
accion_comercial = arrange(accion_comercial, categoria_usuario, resumen_accion_comercial)

  # Calculate the percentages
accion_comercial = ddply(accion_comercial, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100, pos = cumsum((conteo_dist_pers/sum(conteo_dist_pers)) - (0.5 * conteo_dist_pers/sum(conteo_dist_pers)))*100)
accion_comercial$label_percent_dist_pers = paste0(sprintf("%.0f", accion_comercial$percent_dist_pers), "%")

  # Order
accion_comercial = accion_comercial[order(accion_comercial$resumen_accion_comercial, accion_comercial$categoria_usuario),]

  #Graph
graph_accion_comercial <- ggplot(accion_comercial, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = resumen_accion_comercial, label=label_percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("clientes distintos") + 
  ggtitle("Recepción de acción comercial en la app") + 
  geom_text(aes(y = pos, label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_accion_comercial

```   

**No nos consta que algún cliente haya recibido una acción comercial en el último trimestre. **

<br/> 

***Combinación de funcionalidades: % de clientes que han usado todas las funcionalidades, o 6 de ellas o 5 etc.***
<br/> 
```{r FUNCIONALIDADES_RESUMEN_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}

funcionalidades <- qhive("select categoria_usuario,
                          activacion_tarjetas + bloqueo_tarjetas + num_movimientos + consulta_movim + aplazamiento_pagos + notificaciones + accion_comercial as num_funcionalidades,
                    count(cod_pers_trs) as conteo_dist_pers
                    from da_mariadrav.funcionalidades_datos
                    group by categoria_usuario, activacion_tarjetas + bloqueo_tarjetas + num_movimientos + consulta_movim + aplazamiento_pagos + notificaciones + accion_comercial")

funcionalidades_activos <- qhive("select activacion_tarjetas + bloqueo_tarjetas + num_movimientos + consulta_movim + aplazamiento_pagos + notificaciones + accion_comercial as num_funcionalidades,
                    count(cod_pers_trs) as conteo_dist_pers
                    from da_mariadrav.funcionalidades_datos_activos
                    group by activacion_tarjetas + bloqueo_tarjetas + num_movimientos + consulta_movim + aplazamiento_pagos + notificaciones + accion_comercial")

```

```{r FUNCIONALIDADES_RESUMEN, eval=TRUE, echo=FALSE, cache=TRUE}
#Gráfico
  # Get the levels for type in the required order
funcionalidades = arrange(funcionalidades, categoria_usuario, num_funcionalidades)

# Calculate the % des_ctgcom
funcionalidades = ddply(funcionalidades, .(categoria_usuario), transform, percent_dist_pers = conteo_dist_pers/sum(conteo_dist_pers) * 100, pos = cumsum((conteo_dist_pers/sum(conteo_dist_pers)) - (0.5 * conteo_dist_pers/sum(conteo_dist_pers)))*100)

funcionalidades$label_percent_dist_pers = paste(sprintf("%.0f", funcionalidades$percent_dist_pers ),"%")

# Order
funcionalidades = funcionalidades[order(funcionalidades$num_funcionalidades, funcionalidades$categoria_usuario),]

#Graph
graph_funcionalidades <- ggplot(funcionalidades, aes(x = factor(categoria_usuario), y = percent_dist_pers, fill = factor(num_funcionalidades), label=percent_dist_pers, ymax=max(percent_dist_pers))) + 
  geom_bar(stat = "identity", width = .7) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) + 
  ylab("% clientes distintos") + 
  ggtitle("# funcionalidades usadas") + 
  geom_text(aes(label = label_percent_dist_pers), position = "stack", size = 3.5) +
  scale_fill_brewer()
graph_funcionalidades

cast(funcionalidades[,c(1,2,5)], num_funcionalidades ~ categoria_usuario)


#Gráfico en el último trimestre
  # Calculate the percentages
funcionalidades_activos$percent_dist_pers = funcionalidades_activos$conteo_dist_pers/sum(funcionalidades_activos$conteo_dist_pers) * 100
funcionalidades_activos$label_percent_dist_pers = paste0(sprintf("%.0f", funcionalidades_activos$percent_dist_pers), "%")
funcionalidades_activos$num_funcionalidades = ifelse(is.na(funcionalidades_activos$num_funcionalidades),0, funcionalidades_activos$num_funcionalidades)

  #Graph
graph_funcionalidades_activos <- ggplot(funcionalidades_activos, aes(x = factor(num_funcionalidades), y = percent_dist_pers, fill = num_funcionalidades, label=label_percent_dist_pers, ymax=(max(percent_dist_pers)+0.1*max(percent_dist_pers)))) + 
  geom_bar(stat = "identity", width = .7, fill='lightblue') + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank()) +
  ylab("Clientes distintos") + 
  ggtitle(expression(atop(paste('# Funcionalidades usadas'), atop(italic(paste('Clientes Wallet Activos, último trimestre')), ""))))  + 
  theme(legend.position="none") + 
  geom_text(aes(y = percent_dist_pers), position = "stack", size = 3.5, vjust=-2)
graph_funcionalidades_activos

```

<br/>
**5. Estudio tenencia otros productos financieros en BBVA (hipoteca, préstamos, depósitos, planes de pensiones, nóminas/pensiones domiciliadas, etc.)**
<br/>

* Se calcula el número de clientes que tienen al menos un producto. Pueden aparecer clientes sin productos porque se cruza información de diferentes fuentes.
<br/> 
```{r TENENCIA_PRODUCTOS_DATOS, eval=TRUE, echo=FALSE, cache=TRUE}
qhive("select categoria_usuario, 
       sum(case when ind_contrapartida=1 then 1 else 0 end) as Tiene_productos,
       sum(case when ind_contrapartida=0 then 1 else 0 end) as No_tiene_productos
       from(SELECT categoria_usuario, cod_pers_trs, ind_contrapartida,
            rank() over (PARTITION BY categoria_usuario, cod_pers_trs ORDER BY ind_contrapartida DESC) as rank
            FROM (SELECT DISTINCT categoria_usuario, cod_pers_trs,
                  case when des_contrapartida is not null then 1 else 0 end as ind_contrapartida
                  FROM da_mariadrav.wallet_tablon_analisis_investigacion_entrega
                  ) a
             ) r where rank=1
        group by categoria_usuario")
```

<br/> 

* Se calcula el número de clientes que tienen cada uno de los productos.
<br/> 
```{r TENENCIA_PRODUCTOS1, eval=TRUE, echo=FALSE, cache=TRUE}
#Penetración de productos por número de clientes descediente

produ <- qhive("select categoria_usuario,
                    des_contrapartida, 
                    count(distinct cod_pers_trs) as num_clientes 
                    from da_mariadrav.productos_comb where des_contrapartida !=''
                    group by categoria_usuario, des_contrapartida")
```   

```{r TENENCIA_PRODUCTOS2, eval=TRUE, echo=FALSE, cache=TRUE, warning=FALSE, fig.width=10, fig.height=10, echo=FALSE}

# Get the levels for type in the required order
produ = arrange(produ, des_contrapartida, categoria_usuario)

# Calculate the %
produ = ddply(produ, .(des_contrapartida), transform, percent_dist_pers = num_clientes/sum(num_clientes) * 100)
produ$label_percent_dist_pers = paste(sprintf("%.0f", produ$percent_dist_pers ),"%")

# Order
produ = produ[order(produ$categoria_usuario, desc(produ$num_clientes) ),]

graph_produ <- ggplot(produ, aes(x=des_contrapartida, y=num_clientes, fill = categoria_usuario, label="", ymax=max(num_clientes))) + 
  geom_bar(stat = "identity",position='dodge', width=1) + 
  theme(axis.title.x = element_blank(), axis.text.x  = element_text(size=10), legend.title=element_blank(), axis.text.y  = element_text(size=8), legend.position="bottom") +
  xlab("Producto") + 
  ggtitle(expression(atop(paste('# de clientes que tienen contratado algún producto'), atop(italic(paste('Clientes distribuidos por categoria de usuario')), ""))))  + 
  geom_text(aes(y = num_clientes), position = "dodge", size = 3.5) +
   scale_fill_brewer() +
  coord_flip() 
graph_produ

```   

<br/>

*Número de clientes que tienen contratado algún producto* <br/>
```{r TENENCIA_PRODUCTOS3, eval=TRUE, echo=FALSE, cache=TRUE, warning=FALSE, echo=FALSE}
cast(produ[, c(1,2,3)],  des_contrapartida ~ categoria_usuario)
```   

<br/>

*% de clientes que tienen contratado algún producto distribuidos por categoria de usuario* <br/>
```{r TENENCIA_PRODUCTOS4, eval=TRUE, echo=FALSE, cache=TRUE, warning=FALSE, echo=FALSE}
cast(produ[, c(1,2,5)],  des_contrapartida ~ categoria_usuario)
```   


```{r eval=FALSE, echo=FALSE, cache=TRUE, warning=FALSE, echo=FALSE}
# produ2$label_Wallet_Activo = paste(sprintf("%.0f", produ2$Wallet_Activo ),"%")

# produ2$label_Wallet_Inactivo = paste(sprintf("%.0f", produ2$Wallet_Inactivo ),"%")

# produ2$label_BBVANet = paste(sprintf("%.0f", produ2$BBVANet),"%")

```

<br/> 

#ANEXO#
<br/> 

***Tarjetas Habituales***
<br/> *Dado que hay muchos tipos de tarjetas se seleccionar aquellas que son más comunes:*

| COD_comprod | des_comprod                            |
|:-----------:|:--------------------------------------:|
|    2369     | TARJETA DESPUES BBVA                   |
|    2265     | TARJETA AHORA BBVA                     |
|    6709     | TARJETA DIEZ                           |
|    2366     | TARJETA AHORA BLUE BBVA                |
|    3037     | PACK-DUO BBVA                          |
|    9994     | TARJETA ANTES BBVA                     |
|    2497     | TARJETA A TU RITMO BBVA                |
|    2154     | TARJETA BLUE BBVA                      |
|    2306     | TARJETA VIRTUAL BBVA                   |
|    7938     | TARJETA A TU RITMO COMPLEMENTARIA BBVA |
|    9482     | TARJETA 3 MESES SIN                    |
|    2494     | TARJETA DESPUES BLUE BBVA              |
|    2496     | TARJETA DESPUES ORO BBVA               |
|    4169     | TARJETA ANTES BLUE BBVA                |
|    0561     | TARJETA NEGOCIOS DEBITO                |
|    9841     | TARJETA NEGOCIOS CREDITO               |
|    5990     | TARJETA BLUE BBVA MENSUAL              |
|    6048     | TARJETA LIGA BBVA                      |
|    2511     | TARJETA A TU RITMO BLUE BBVA           |
|    5989     | TARJETA DIEZ MENSUAL                   |


***FUENTES***

*SINFO - NFC:*

* Telefono validado - tfno_gest
* email validado - email
* Indicador de móvil validado - inf_movil
* Indicador de email validado - inf_email
* Edad - edad_edad
* Género - sexo_sexo
* Antigüedad BBVA
* Nombre y Apellidos

*clarity_attributes.Big_Big_table:*

* Ciudad - cod_postal_ciudad_des_ciudadg
* Segmento según Plan Uno -  segmento_plan_uno_cod_segmento_plan_uno

*clarity_elements.metricas_segm_comport, da_pro.transacciones_por_canal*

* Tipología usuario Banca Online (según alguna segmentación interna sobre nivel de uso de BO) -  segmento_comportamental <= 6
* Franjas horarias de conexión

*da_martalamela.wallet_antiguedad_usuarios*

* Antigüedad en BBVA Wallet -  antiguedad_days

*da_pro.productos_contratados*

* Tenencia de tarjeta wallet - cod_comprod = 8425
* Tenencia de sticker - cod_comprod = 3199
* Nº medio de tarjetas activas-  distinct cod_idcontra para cod_comprod 3199, 8425
* Tenencia otros productos financieros en BBVA (hipoteca, préstamos, depósitos, planes de pensiones, nóminas/pensiones domiciliadas, etc.)- des_ctgcom

*da_pro.movimientos_tarjeta_detalle_corp*

* Nº operaciones realizadas Tarjeta wallet e importes - count(all), suma importe
* Modalidad de pago Tarjeta Wallet - join productos_contratados y ver cod_comprod 3199, 8425
* NO SE ENCONTRÓ INFORMACION: Si pre-pago: importes medios recargados - ¿pago en comercio online? ¿todos los 3199?

*Funcionalidades*

*da_pro.transacciones_por_canal*

* 1. activación de tarjetas - cod_trnfims 1231
* 4. consulta de movimientos - cod_trnfims 0190 o TCTFT976 o 0559 (prepago)
* 5. aplazamiento de pagos - cod_trnfims 1620 o TCTFTL66
* 6. recepción de notificaciones - cod_trnfims 1681 (baja) o 1680 (alta)

*da_pro.movimientos_tarjeta_detalle_corp*

* 3. pago móvil, diferenciando si ha sido con o sin sticker -	cod_comprod 3199, 8425

*sinfo_master.oportunidades_comerciales*

* 7. uso de promociones: Sólo existe información de clientes que recibieron alguna oferta comercial wallet (cupones etc.) y no del éxito de ellas -	cod_acom wallet

*da_pro.productos_contratados, da_pro.productos_contratados_detalle, da_pro.saldos_cuenta_persona_fisica*

* Otros productos contratados

